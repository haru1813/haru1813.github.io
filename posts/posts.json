{
  "posts": [
    {
      "id": "solid-overview",
      "title": "SOLID 원칙 개요",
      "date": "2026-02-11",
      "summary": "SOLID는 객체지향 설계의 5가지 핵심 원칙입니다. Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion를 한눈에 정리합니다.",
      "category": "Technology/SOLID",
      "tags": [
        "theory",
        "solid",
        "oop",
        "design-principles"
      ],
      "content": [
        "## SOLID란?",
        "SOLID는 로버트 C. 마틴(Robert C. Martin)이 정리한 객체지향 설계의 5가지 핵심 원칙의 머리글자입니다.",
        "",
        "| 원칙 | 영어 | 한글 | 한 줄 요약 |",
        "|------|------|------|------------|",
        "| S | Single Responsibility | 단일 책임 | 한 클래스는 하나의 변경 이유만 |",
        "| O | Open/Closed | 개방-폐쇄 | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 |",
        "| L | Liskov Substitution | 리스코프 치환 | 하위 타입은 상위 타입을 대체 가능해야 함 |",
        "| I | Interface Segregation | 인터페이스 분리 | 사용하지 않는 메서드에 의존하지 말 것 |",
        "| D | Dependency Inversion | 의존성 역전 | 구체가 아니라 추상에 의존할 것 |",
        "",
        "## 왜 SOLID를 지킬까",
        "- 유지보수성: 변경 범위를 줄이고, 버그를 줄임",
        "- 테스트 용이성: 의존성 분리/역전으로 테스트가 쉬워짐",
        "- 확장성: 새 기능 추가 시 기존 코드 수정 최소화",
        "",
        "---",
        "### 요약",
        "SOLID는 변경에 강한 설계를 위한 5가지 원칙입니다. SRP, OCP, LSP, ISP, DIP를 순서대로 익히면 좋습니다."
      ]
    },
    {
      "id": "mount-overview",
      "title": "마운트(Mount)란?",
      "date": "2026-02-11",
      "summary": "마운트는 저장 장치·파일시스템을 특정 경로(마운트 포인트)에 연결해 접근 가능하게 만드는 것입니다. Linux mount/umount, Windows 드라이브 문자, Docker 볼륨까지 정리합니다.",
      "category": "Coding/Theory",
      "tags": [
        "theory",
        "mount",
        "filesystem",
        "linux",
        "docker",
        "storage"
      ],
      "content": [
        "## 한 줄 요약",
        "마운트(Mount)는 저장 장치나 파일시스템을 디렉터리 트리의 특정 경로에 붙여서 파일처럼 접근할 수 있게 만드는 것입니다.",
        "",
        "## 마운트란?",
        "컴퓨터에는 디스크, USB, 네트워크 공유 폴더 등 여러 저장 공간이 있습니다. 이들을 어디서 접근할지 정해 주는 것이 마운트입니다.",
        "",
        "- 마운트 포인트(Mount Point): 파일시스템이 붙는 디렉터리 경로",
        "- 마운트: 특정 경로에 저장 공간을 연결하는 행위",
        "- 언마운트(Unmount): 연결을 끊는 행위",
        "",
        "## Linux에서의 마운트",
        "```bash",
        "mount /dev/sdb1 /mnt/usb",
        "umount /mnt/usb",
        "mount",
        "df -h",
        "```",
        "",
        "### /etc/fstab",
        "시스템 부팅 시 자동으로 마운트하려면 /etc/fstab에 등록합니다.",
        "",
        "### bind mount",
        "이미 있는 디렉터리를 다른 경로에서도 보이게 할 때 사용합니다.",
        "",
        "```bash",
        "mount --bind /원본/경로 /다른/경로",
        "```",
        "",
        "## Windows에서의 마운트",
        "Windows는 드라이브 문자(C:, D:, E: 등)로 접근합니다. 새 디스크·USB를 꽂으면 자동 할당됩니다.",
        "",
        "## Docker에서의 마운트",
        "| 방식 | 설명 | 예시 |",
        "|------|------|------|",
        "| 볼륨 마운트 | 도커가 관리하는 볼륨을 컨테이너에 연결 | -v myvol:/app/data |",
        "| 바인드 마운트 | 호스트의 특정 경로를 그대로 연결 | -v /data:/app/data |",
        "",
        "---",
        "### 요약",
        "마운트는 디스크·USB·네트워크 공유·도커 볼륨을 특정 경로에 연결해 파일처럼 접근하게 만드는 것입니다."
      ]
    },
    {
      "id": "ssh-overview",
      "title": "SSH(Secure Shell)란?",
      "date": "2026-02-11",
      "summary": "SSH는 네트워크를 통해 원격 컴퓨터에 안전하게 접속하거나 파일을 전송하는 프로토콜입니다. ssh, scp, sftp, 공개키 인증 등 핵심 개념을 정리합니다.",
      "category": "Coding/Theory",
      "tags": [
        "theory",
        "ssh",
        "security",
        "network",
        "remote"
      ],
      "content": [
        "## 한 줄 요약",
        "SSH(Secure Shell)는 네트워크를 통해 원격 컴퓨터에 암호화된 통신으로 접속하는 프로토콜입니다. 비밀번호 대신 키 기반 인증을 쓰면 더 안전합니다.",
        "",
        "## 주요 용도",
        "| 용도 | 설명 |",
        "|------|------|",
        "| 원격 로그인 | 서버에 ssh user@host로 접속해 명령 실행 |",
        "| 파일 전송 | scp, sftp로 암호화된 파일 송수신 |",
        "| Git·배포 | GitHub 등에 SSH 키로 인증, CI/CD에서 서버 접속 |",
        "",
        "## 기본 사용법",
        "",
        "### 원격 접속(ssh)",
        "```bash",
        "ssh user@hostname",
        "ssh -p 2222 user@hostname",
        "ssh -i ~/.ssh/my_key user@hostname",
        "```",
        "",
        "### 파일 전송(scp)",
        "```bash",
        "scp file.txt user@host:/path/to/dest",
        "scp user@host:/path/to/file.txt .",
        "scp -r ./mydir user@host:/path/",
        "```",
        "",
        "### SFTP",
        "```bash",
        "sftp user@host",
        "```",
        "",
        "## SSH 키 인증",
        "비밀번호 대신 공개키/비밀키 쌍으로 인증하면 더 안전합니다.",
        "",
        "```bash",
        "ssh-keygen -t ed25519",
        "ssh-copy-id user@host",
        "```",
        "",
        "## 클라이언트 설정(~/.ssh/config)",
        "```",
        "Host myserver",
        "    HostName 192.168.1.100",
        "    User deploy",
        "    IdentityFile ~/.ssh/my_key",
        "    Port 22",
        "```",
        "",
        "이후 ssh myserver만 입력해 접속 가능.",
        "",
        "---",
        "### 요약",
        "SSH는 원격 컴퓨터에 안전하게 접속하거나 파일을 전송하는 프로토콜입니다. ssh, scp, sftp를 쓰고, 공개키 인증으로 보안을 강화할 수 있습니다."
      ]
    },
    {
      "id": "docker-core-concepts",
      "title": "도커 핵심 개념: 도커, 컨테이너, 도커 엔진, 이미지",
      "date": "2026-02-11",
      "summary": "도커(Docker)와 컨테이너, 도커 엔진, 이미지의 개념과 이들 간의 관계를 정리합니다.",
      "category": "Technology/Docker",
      "tags": [
        "docker",
        "container",
        "image",
        "engine",
        "devops"
      ],
      "content": [
        "## 한 줄 요약",
        "- 도커: 컨테이너 기반 앱을 실행·배포하는 플랫폼",
        "- 컨테이너: 격리된 실행 환경",
        "- 도커 엔진: 컨테이너를 생성·실행·관리하는 핵심 프로그램",
        "- 이미지: 컨테이너를 만들기 위한 읽기 전용 템플릿",
        "",
        "## 관계",
        "이미지 → 도커 엔진 → 컨테이너 생성·실행",
        "",
        "## 도커 엔진 구성",
        "| 구성요소 | 역할 |",
        "|----------|------|",
        "| dockerd | 데몬, 이미지 받아와 컨테이너 생성·실행·관리 |",
        "| containerd | 컨테이너 런타임 관리 |",
        "| runc | 실제 컨테이너 프로세스 생성 |",
        "",
        "---",
        "### 요약",
        "도커는 이미지로 컨테이너를 만들고, 도커 엔진(dockerd, containerd, runc)이 이를 관리합니다."
      ]
    },
    {
      "id": "solid-srp",
      "title": "SOLID-Single Responsibility Principle(단일 책임 원칙)",
      "date": "2026-02-11",
      "summary": "단일 책임 원칙(SRP)은 한 클래스가 하나의 변경 이유만 가져야 한다는 원칙입니다.",
      "category": "Technology/SOLID",
      "tags": [
        "theory",
        "solid",
        "srp",
        "oop"
      ],
      "content": [
        "## SRP란?",
        "Single Responsibility Principle(단일 책임 원칙)은 한 클래스가 하나의 책임만, 즉 하나의 변경 이유만 가져야 한다는 원칙입니다.",
        "",
        "## 위반 예시",
        "User 클래스가 사용자 정보 저장 + 이메일 발송 + 로그 기록을 모두 담당하면 SRP 위반입니다.",
        "",
        "```java",
        "public class User {",
        "    public void save() { /* DB 저장 */ }",
        "    public void sendEmail() { /* 이메일 발송 */ }",
        "    public void log() { /* 로그 기록 */ }",
        "}",
        "```",
        "",
        "## 개선 예시",
        "```java",
        "public class User { /* 데이터만 */ }",
        "public class UserRepository { public void save(User u) { } }",
        "public class EmailService { public void send(User u, String msg) { } }",
        "```",
        "",
        "---",
        "### 요약",
        "SRP는 하나의 클래스가 하나의 변경 이유만 가지도록 책임을 분리하는 원칙입니다."
      ]
    },
    {
      "id": "solid-ocp",
      "title": "SOLID-Open/Closed Principle(개방-폐쇄 원칙)",
      "date": "2026-02-11",
      "summary": "개방-폐쇄 원칙(OCP)은 확장에는 열려 있고, 수정에는 닫혀 있어야 한다는 원칙입니다.",
      "category": "Technology/SOLID",
      "tags": [
        "theory",
        "solid",
        "ocp",
        "oop"
      ],
      "content": [
        "## OCP란?",
        "Open/Closed Principle(개방-폐쇄 원칙)은 소프트웨어 요소는 확장에는 열려 있으나 수정에는 닫혀 있어야 한다는 원칙입니다.",
        "",
        "## 요약",
        "새 기능 추가 시 기존 코드를 수정하지 않고, 확장(새 클래스/인터페이스 구현)으로 처리합니다."
      ]
    },
    {
      "id": "solid-lsp",
      "title": "SOLID-Liskov Substitution Principle(리스코프 치환 원칙)",
      "date": "2026-02-11",
      "summary": "리스코프 치환 원칙(LSP)은 하위 타입이 상위 타입을 대체했을 때 프로그램의 정확성이 깨지지 않아야 한다는 원칙입니다.",
      "category": "Technology/SOLID",
      "tags": [
        "theory",
        "solid",
        "lsp",
        "oop"
      ],
      "content": [
        "## LSP란?",
        "Liskov Substitution Principle(리스코프 치환 원칙)은 하위 타입은 상위 타입을 대체했을 때, 프로그램의 정확성이 깨지지 않아야 한다는 원칙입니다.",
        "",
        "## 위반 예시",
        "Rectangle을 상속한 Square가 setWidth/setHeight 시 상위 타입과 다르게 동작하는 경우.",
        "",
        "## 개선 예시",
        "Square가 Rectangle을 상속하지 않고, 공통 인터페이스 Shape로 분리하면 LSP를 지킬 수 있습니다.",
        "",
        "---",
        "### 요약",
        "LSP는 하위 타입이 상위 타입의 계약을 지켜야 한다는 원칙입니다."
      ]
    },
    {
      "id": "solid-isp",
      "title": "SOLID-Interface Segregation Principle(인터페이스 분리 원칙)",
      "date": "2026-02-11",
      "summary": "인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 메서드에 의존하지 않아야 한다는 원칙입니다.",
      "category": "Technology/SOLID",
      "tags": [
        "theory",
        "solid",
        "isp",
        "oop"
      ],
      "content": [
        "## ISP란?",
        "Interface Segregation Principle(인터페이스 분리 원칙)은 클라이언트는 자신이 사용하지 않는 메서드에 의존해서는 안 된다는 원칙입니다.",
        "",
        "큰 인터페이스 하나보다, 작고 구체적인 인터페이스 여러 개가 낫습니다.",
        "",
        "---",
        "### 요약",
        "ISP는 클라이언트별로 필요한 메서드만 노출하는 원칙입니다."
      ]
    },
    {
      "id": "solid-dip",
      "title": "SOLID-Dependency Inversion Principle(의존성 역전 원칙)",
      "date": "2026-02-11",
      "summary": "의존성 역전 원칙(DIP)은 구체가 아니라 추상에 의존해야 한다는 원칙입니다.",
      "category": "Technology/SOLID",
      "tags": [
        "theory",
        "solid",
        "dip",
        "oop"
      ],
      "content": [
        "## DIP란?",
        "Dependency Inversion Principle(의존성 역전 원칙)은 고수준 모듈은 저수준 모듈에 의존하면 안 되며, 둘 다 추상화에 의존해야 한다는 원칙입니다.",
        "",
        "---",
        "### 요약",
        "DIP는 구체가 아니라 추상(인터페이스, 추상클래스)에 의존하라는 원칙입니다."
      ]
    },
    {
      "id": "container-image-relationship",
      "title": "컨테이너와 이미지의 관계",
      "date": "2026-02-11",
      "summary": "이미지는 읽기 전용 템플릿, 컨테이너는 그 이미지로부터 생성된 실행 인스턴스입니다.",
      "category": "Technology/Docker",
      "tags": [
        "docker",
        "container",
        "image",
        "relationship",
        "layers"
      ],
      "content": [
        "## 한 줄 요약",
        "- 이미지: 컨테이너를 만들기 위한 읽기 전용 템플릿",
        "- 컨테이너: 이미지를 기반으로 생성된, 실행 중인 인스턴스",
        "",
        "## 클래스와 객체 비유",
        "| 개념 | 프로그래밍 비유 |",
        "|------|-----------------|",
        "| 이미지 | 클래스(설계도) |",
        "| 컨테이너 | 객체(인스턴스) |",
        "",
        "다만 docker commit으로 컨테이너 → 이미지가 가능해 경계가 일방향만은 아닙니다.",
        "",
        "## 핵심 정리",
        "- 이미지가 있으면 컨테이너를 만들 수 있음",
        "- 같은 이미지 → 여러 컨테이너(1:N)",
        "",
        "---",
        "### 요약",
        "이미지는 읽기 전용 템플릿, 컨테이너는 그 이미지로부터 만들어진 실행 인스턴스입니다."
      ]
    },
    {
      "id": "docker-hub",
      "title": "도커 허브(Docker Hub)란?",
      "date": "2026-02-11",
      "summary": "Docker Hub는 도커 이미지를 저장·공유하는 공식 레지스트리 서비스입니다.",
      "category": "Technology/Docker",
      "tags": [
        "docker",
        "docker-hub",
        "registry",
        "image",
        "pull",
        "push"
      ],
      "content": [
        "## 한 줄 요약",
        "Docker Hub는 도커 이미지를 저장·공유하는 클라우드 레지스트리입니다. GitHub가 코드를, Docker Hub는 이미지를 호스팅합니다.",
        "",
        "## 주요 기능",
        "| 기능 | 설명 |",
        "|------|------|",
        "| pull | docker pull로 이미지 받기 |",
        "| push | docker push로 이미지 올리기 |",
        "| 공개/비공개 | 저장소 공개 여부 설정 |",
        "",
        "---",
        "### 요약",
        "Docker Hub는 docker pull, docker push의 기본 대상 레지스트리입니다."
      ]
    },
    {
      "id": "docker-pros-cons-use-cases",
      "title": "도커의 장점, 단점, 용도",
      "date": "2026-02-11",
      "summary": "도커의 장점(일관된 환경, 빠른 배포 등), 단점(보안·디버깅 한계 등), 적합한 용도를 정리합니다.",
      "category": "Technology/Docker",
      "tags": [
        "docker",
        "pros",
        "cons",
        "use-cases",
        "devops"
      ],
      "content": [
        "## 장점",
        "- 환경 일관성, 빠른 배포, 리소스 효율, 마이크로서비스에 적합",
        "",
        "## 단점",
        "- 보안·격리 한계, 디버깅 복잡도, 학습 곡선",
        "",
        "## 용도",
        "앱 배포, 로컬 개발, CI/CD, 테스트·스테이징, 마이크로서비스",
        "",
        "---",
        "### 요약",
        "도커는 환경 일관성과 배포 효율에서 강점이 있습니다."
      ]
    },
    {
      "id": "docker-desktop",
      "title": "도커 데스크톱(Docker Desktop)이란?",
      "date": "2026-02-11",
      "summary": "Docker Desktop은 Windows와 Mac에서 도커를 쉽게 사용할 수 있게 해주는 GUI 애플리케이션입니다.",
      "category": "Technology/Docker",
      "tags": [
        "docker",
        "docker-desktop",
        "gui",
        "windows",
        "mac",
        "wsl2"
      ],
      "content": [
        "## 한 줄 요약",
        "Docker Desktop은 Windows·Mac에서 도커 엔진을 쉽게 설치·실행할 수 있게 해주는 GUI 애플리케이션입니다.",
        "",
        "## 주요 기능",
        "- WSL2(Hyper-V) 위에 Linux 도커 엔진 실행",
        "- 컨테이너·이미지·볼륨 GUI 관리",
        "",
        "---",
        "### 요약",
        "Docker Desktop은 Windows·Mac에서 도커를 쉽게 쓸 수 있게 해주는 앱입니다."
      ]
    },
    {
      "id": "docker-vs-virtualization",
      "title": "도커 vs 가상화 기술(VM) 차이점",
      "date": "2026-02-11",
      "summary": "도커(컨테이너)와 전통적인 가상화(VM)의 차이를 정리합니다.",
      "category": "Technology/Docker",
      "tags": [
        "docker",
        "virtualization",
        "vm",
        "container",
        "comparison"
      ],
      "content": [
        "## 한눈에 비교",
        "| 구분 | 가상화(VM) | 도커(컨테이너) |",
        "|------|------------|----------------|",
        "| 격리 단위 | VM 전체(Guest OS 포함) | 프로세스·파일시스템·네트워크 |",
        "| OS | 각 VM마다 Guest OS 필요 | 호스트 커널 공유 |",
        "| 부팅 시간 | 수십 초~수 분 | 1초 이내 |",
        "",
        "---",
        "### 요약",
        "도커는 커널을 공유해 VM보다 가볍고 빠릅니다."
      ]
    },
    {
      "id": "container-os-reality",
      "title": "컨테이너에서 돌아가는 OS의 실체",
      "date": "2026-02-11",
      "summary": "컨테이너 안의 Alpine/Ubuntu는 전체 OS가 아니라 rootfs입니다. 커널은 호스트와 공유합니다.",
      "category": "Technology/Docker",
      "tags": [
        "docker",
        "container",
        "os",
        "rootfs",
        "kernel"
      ],
      "content": [
        "## 핵심",
        "컨테이너에 있는 건 OS 전체가 아니라 rootfs(파일 트리 + 도구)입니다. 커널은 호스트와 공유하고, Alpine/Ubuntu 베이스 이미지는 그 파일 구조와 유틸리티를 제공할 뿐입니다.",
        "",
        "---",
        "### 요약",
        "컨테이너의 OS는 rootfs이며, 커널은 호스트 것을 공유합니다."
      ]
    },
    {
      "id": "engine-in-software",
      "title": "엔진(Engine)이란?",
      "date": "2026-02-11",
      "summary": "소프트웨어에서 엔진은 특정 기능을 담당하는 핵심 컴포넌트를 말합니다.",
      "category": "Coding/Theory",
      "tags": [
        "theory",
        "engine",
        "architecture",
        "basics"
      ],
      "content": [
        "## 엔진이란?",
        "소프트웨어에서 엔진은 특정 기능을 담당하는 핵심 컴포넌트를 말합니다.",
        "",
        "| 종류 | 예시 |",
        "|------|------|",
        "| 검색 엔진 | Elasticsearch |",
        "| 게임 엔진 | Unity, Unreal |",
        "| JS 엔진 | V8, SpiderMonkey |",
        "| 렌더링 엔진 | Blink, WebKit |",
        "",
        "---",
        "### 요약",
        "엔진은 특정 기능의 핵심 구현체입니다."
      ]
    },
    {
      "id": "server-overview",
      "title": "서버(Server)란?",
      "date": "2026-02-11",
      "summary": "서버는 클라이언트의 요청에 응답하는 프로그램 또는 컴퓨터입니다.",
      "category": "Coding/Theory",
      "tags": [
        "theory",
        "server",
        "architecture",
        "backend"
      ],
      "content": [
        "## 서버란?",
        "서버는 클라이언트의 요청을 받아 응답을 제공하는 프로그램, 또는 그 프로그램이 실행되는 컴퓨터를 말합니다.",
        "",
        "## 대표 서버 종류",
        "| 종류 | 역할 | 예시 |",
        "|------|------|------|",
        "| 웹 서버 | HTTP 요청, 정적 파일 제공 | Nginx, Apache, Caddy |",
        "| 애플리케이션 서버 | 동적 로직, DB 연동 | Tomcat, Node.js, Spring Boot |",
        "| DB 서버 | 데이터 저장·조회 | MySQL, PostgreSQL, MongoDB |",
        "| 메일 서버 | 이메일 발송·수신 | Postfix, SendGrid |",
        "| 파일 서버 | 파일 공유·저장 | NAS, FTP, S3 |",
        "| DNS 서버 | 도메인 → IP 변환 | Google DNS, BIND |",
        "| 프록시 서버 | 요청 대신 전달, 캐싱 | Nginx, Squid, Cloudflare |",
        "| DHCP 서버 | IP 자동 할당 | 라우터 내장, dnsmasq |",
        "| 인증 서버 | 로그인, 토큰 발급 | LDAP, Keycloak, Auth0 |",
        "",
        "---",
        "### 요약",
        "서버는 클라이언트 요청에 응답하는 프로그램/장비입니다. 웹·앱·DB·메일·파일·DNS·프록시·DHCP·인증 서버 등 다양한 종류가 있습니다."
      ]
    },
    {
      "id": "python-print",
      "title": "print",
      "date": "2026-02-11",
      "summary": "Python의 print() 함수는 값을 화면에 출력하는 가장 기본적인 방법입니다.",
      "category": "Coding/Python",
      "tags": [
        "python",
        "print",
        "basics",
        "output"
      ],
      "content": [
        "## print()란?",
        "print()는 Python에서 값을 표준 출력(화면)에 출력하는 내장 함수입니다.",
        "",
        "## 1) 하나만 출력",
        "```python",
        "print(\"hello world!\")",
        "print(42)",
        "print(3.14)",
        "```",
        "",
        "## 2) 여러 개 출력 (쉼표로 구분)",
        "여러 값을 쉼표로 나열하면 공백으로 구분되어 한 줄에 출력됩니다.",
        "",
        "```python",
        "print(10, 20, 30, 40, 50)",
        "```",
        "",
        "## 3) sep(구분자)와 end(끝 문자)",
        "- sep: 값들 사이에 들어갈 문자 (기본값: 공백)",
        "- end: 출력 끝에 붙을 문자 (기본값: 줄바꿈)",
        "",
        "```python",
        "print(1, 2, 3, sep=\"-\")   # 1-2-3",
        "print(\"A\", end=\"\")",
        "print(\"B\", end=\"\")",
        "print(\"C\")              # ABC",
        "```",
        "",
        "## 4) f-string 포맷팅 (Python 3.6+)",
        "```python",
        "name = \"김철수\"",
        "age = 25",
        "print(f\"이름: {name}, 나이: {age}\")",
        "print(f\"원의 넓이: {3.14 * 5 ** 2:.2f}\")",
        "```",
        "",
        "## 5) format() 메서드",
        "```python",
        "print(\"{}의 나이는 {}살입니다.\".format(\"홍길동\", 25))",
        "```",
        "",
        "## 6) 이스케이프 문자",
        "```python",
        "print(\"줄바꿈\\n두 번째 줄\")",
        "print(\"탭\\t사이\")",
        "print(\"따옴표: \\\"문자\\\"\")",
        "```",
        "",
        "---",
        "### 요약",
        "print()는 Python에서 화면에 값을 출력하는 기본 함수입니다. sep, end, f-string, format() 등으로 다양한 출력이 가능합니다."
      ]
    },
    {
      "id": "abstract-factory-pattern",
      "title": "Abstract Factory(추상 팩토리) 패턴",
      "date": "2026-02-11",
      "summary": "관련된 여러 객체(제품군)를 한 묶음으로 생성하는 패턴. 제품군 단위로 구현을 교체할 수 있습니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Abstract Factory(추상 팩토리) 패턴이란?",
        "관련된 여러 객체(제품군)를 한 묶음으로 생성하는 패턴. 제품군 단위로 구현을 교체할 수 있습니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "관련된 여러 객체(제품군)를 한 묶음으로 생성하는 패턴. 제품군 단위로 구현을 교체할 수 있습니다."
      ]
    },
    {
      "id": "builder-pattern",
      "title": "Builder(빌더) 패턴",
      "date": "2026-02-11",
      "summary": "복잡한 객체를 단계적으로 생성하는 패턴. 가독성과 불변성을 높입니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Builder(빌더) 패턴이란?",
        "복잡한 객체를 단계적으로 생성하는 패턴. 가독성과 불변성을 높입니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "복잡한 객체를 단계적으로 생성하는 패턴. 가독성과 불변성을 높입니다."
      ]
    },
    {
      "id": "singleton-pattern",
      "title": "Singleton(싱글톤) 패턴",
      "date": "2026-02-11",
      "summary": "인스턴스가 하나만 존재하도록 보장하는 패턴. 전역 공유 자원에 사용되지만, 테스트/멀티스레드에서 주의가 필요합니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Singleton(싱글톤) 패턴이란?",
        "인스턴스가 하나만 존재하도록 보장하는 패턴. 전역 공유 자원에 사용되지만, 테스트/멀티스레드에서 주의가 필요합니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "인스턴스가 하나만 존재하도록 보장하는 패턴. 전역 공유 자원에 사용되지만, 테스트/멀티스레드에서 주의가 필요합니다."
      ]
    },
    {
      "id": "adapter-pattern",
      "title": "Adapter(어댑터) 패턴",
      "date": "2026-02-11",
      "summary": "인터페이스가 다른 객체를 우리가 기대하는 형태로 감싸는 패턴. 레거시·외부 라이브러리 연결에 유용합니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Adapter(어댑터) 패턴이란?",
        "인터페이스가 다른 객체를 우리가 기대하는 형태로 감싸는 패턴. 레거시·외부 라이브러리 연결에 유용합니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "인터페이스가 다른 객체를 우리가 기대하는 형태로 감싸는 패턴. 레거시·외부 라이브러리 연결에 유용합니다."
      ]
    },
    {
      "id": "decorator-pattern",
      "title": "Decorator(데코레이터) 패턴",
      "date": "2026-02-11",
      "summary": "객체를 감싸서 기능을 동적으로 추가하는 패턴. 로그, 인증, 캐싱 등을 조합할 때 유용합니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Decorator(데코레이터) 패턴이란?",
        "객체를 감싸서 기능을 동적으로 추가하는 패턴. 로그, 인증, 캐싱 등을 조합할 때 유용합니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "객체를 감싸서 기능을 동적으로 추가하는 패턴. 로그, 인증, 캐싱 등을 조합할 때 유용합니다."
      ]
    },
    {
      "id": "facade-pattern",
      "title": "Facade(퍼사드) 패턴",
      "date": "2026-02-11",
      "summary": "복잡한 하위 시스템을 단순한 창구로 감싸는 패턴. 클라이언트가 여러 모듈을 한 번에 호출할 수 있게 합니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Facade(퍼사드) 패턴이란?",
        "복잡한 하위 시스템을 단순한 창구로 감싸는 패턴. 클라이언트가 여러 모듈을 한 번에 호출할 수 있게 합니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "복잡한 하위 시스템을 단순한 창구로 감싸는 패턴. 클라이언트가 여러 모듈을 한 번에 호출할 수 있게 합니다."
      ]
    },
    {
      "id": "proxy-pattern",
      "title": "Proxy(프록시) 패턴",
      "date": "2026-02-11",
      "summary": "실제 객체 접근을 제어하는 대리 객체. 지연 로딩, 캐싱, 권한 체크에 사용됩니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Proxy(프록시) 패턴이란?",
        "실제 객체 접근을 제어하는 대리 객체. 지연 로딩, 캐싱, 권한 체크에 사용됩니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "실제 객체 접근을 제어하는 대리 객체. 지연 로딩, 캐싱, 권한 체크에 사용됩니다."
      ]
    },
    {
      "id": "strategy-pattern",
      "title": "Strategy(전략) 패턴",
      "date": "2026-02-11",
      "summary": "알고리즘을 교체 가능하게 만드는 패턴. 결제 방식, 정렬 방식 등에 사용됩니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Strategy(전략) 패턴이란?",
        "알고리즘을 교체 가능하게 만드는 패턴. 결제 방식, 정렬 방식 등에 사용됩니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "알고리즘을 교체 가능하게 만드는 패턴. 결제 방식, 정렬 방식 등에 사용됩니다."
      ]
    },
    {
      "id": "observer-pattern",
      "title": "Observer(관찰자) 패턴",
      "date": "2026-02-11",
      "summary": "상태 변화를 구독자에게 알리는 패턴. 이벤트/구독 모델의 기반입니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Observer(관찰자) 패턴이란?",
        "상태 변화를 구독자에게 알리는 패턴. 이벤트/구독 모델의 기반입니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "상태 변화를 구독자에게 알리는 패턴. 이벤트/구독 모델의 기반입니다."
      ]
    },
    {
      "id": "command-pattern",
      "title": "Command(명령) 패턴",
      "date": "2026-02-11",
      "summary": "요청을 객체로 캡슐화하는 패턴. 실행/취소/재시도, 큐에 넣기 등에 사용됩니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## Command(명령) 패턴이란?",
        "요청을 객체로 캡슐화하는 패턴. 실행/취소/재시도, 큐에 넣기 등에 사용됩니다.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "요청을 객체로 캡슐화하는 패턴. 실행/취소/재시도, 큐에 넣기 등에 사용됩니다."
      ]
    },
    {
      "id": "state-pattern",
      "title": "State(상태) 패턴",
      "date": "2026-02-11",
      "summary": "상태에 따라 동작이 달라질 때 조건문 대신 상태 객체로 분리하는 패턴.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "oop"
      ],
      "content": [
        "## State(상태) 패턴이란?",
        "상태에 따라 동작이 달라질 때 조건문 대신 상태 객체로 분리하는 패턴.",
        "",
        "## 핵심",
        "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.",
        "",
        "---",
        "### 요약",
        "상태에 따라 동작이 달라질 때 조건문 대신 상태 객체로 분리하는 패턴."
      ]
    },
    {
      "id": "hello-pages",
      "title": "블로그 소개",
      "date": "2026-02-11",
      "summary": "공부 기록을 차곡차곡 모으는 블로그입니다.",
      "category": "Daily Life/ETC",
      "tags": [
        "blog"
      ],
      "content": [
        "## 안녕하세요.",
        "haru1813 개발 블로그에 오신 것을 환영합니다.",
        "",
        "공부한 내용을 정리해 기록합니다."
      ]
    },
    {
      "id": "ai-era-developer-growth",
      "title": "AI가 발전하는 시대, 개발자는 무엇을 자기개발해야 할까",
      "date": "2026-02-10",
      "summary": "코드를 ‘더 빨리’ 쓰는 것보다, 문제를 정의하고 해결하는 능력을 키우는 쪽으로 자기개발의 무게중심이 이동합니다.",
      "category": "Coding/Theory",
      "tags": [
        "theory",
        "career",
        "problem-solving"
      ],
      "content": [
        "## 들어가며",
        "AI가 점점 더 많은 코드를 대신 작성해주는 시대가 오고 있습니다. 이럴수록 개발자의 가치는 “타이핑 속도”가 아니라 문제를 제대로 정의하고, 올바른 해결책을 끝까지 완성하는 능력에서 나옵니다.",
        "",
        "## 결론부터",
        "- AI가 잘하는 것: 빠른 초안 생성, 코드 변환, 반복 작업 자동화",
        "- 개발자가 계속 잘해야 하는 것: 문제 정의, 우선순위, 품질 기준, 트레이드오프 판단, 검증과 운영",
        "",
        "## 문제의 정의 및 해결 5단계",
        "아래 5가지는 훈련으로 좋아집니다. 중요한 건 “머릿속”이 아니라 글로 남기는 습관이에요.",
        "",
        "### 1) 나의 자원과 상황을 파악하는 연습부터 한다",
        "- 지금 내가 가진 자원(시간/체력/돈/환경/도구/지식/협업 가능 여부)은 무엇인가?",
        "- 이번 문제에서 가장 큰 제약은 무엇인가? (마감, 성능, 품질, 보안, 유지보수, 학습 목적 등)",
        "- 오늘 가능한 최선은 무엇인가? (완벽 대신 “현실적 최적”)",
        "",
        "### 2) 목표를 “완료 여부가 명확하게” 정의하는 연습",
        "- 목표는 ‘성공/실패’를 분명히 판정할 수 있어야 합니다.",
        "- 나쁜 예: “성능 개선하기”, “좀 더 예쁘게 만들기”",
        "- 좋은 예: “LCP 2.5초 이하”, “배포 후 404 0건”, “로그인 성공률 99.9% 이상”",
        "",
        "### 3) 목표를 세부 단계로 쪼개는 훈련",
        "- 큰 목표를 작은 작업 단위로 나눕니다.",
        "- 각 단계는 ‘다음 행동’을 바로 할 수 있을 정도로 구체적이어야 합니다.",
        "- 예: 요구사항 정리 → 데이터/화면 설계 → 구현 → 테스트 → 배포 → 모니터링",
        "",
        "### 4) 발생할 문제를 미리 예측하는 연습",
        "- 실패 시나리오를 먼저 써봅니다.",
        "- 예: “권한이 꼬이면?”, “데이터가 비정상 값이면?”, “트래픽이 늘면?”, “배포 중 장애가 나면?”",
        "- 그리고 각각에 대해 최소한의 방어막(검증, 롤백, 로그, 알림)을 준비합니다.",
        "",
        "### 5) “그럼 어떻게 할지”를 글로 적는 연습",
        "- 마지막으로 실행 계획을 짧은 문장으로 씁니다.",
        "- 형식 예:",
        "- 오늘 할 일: …",
        "- 완료 조건: …",
        "- 리스크/대응: …",
        "- 다음 행동(바로 지금): …",
        "",
        "## 그럼 어떤 공부를 해야 할까",
        "AI가 코드를 도와줄수록, 아래 능력들이 더 중요해집니다.",
        "",
        "### (1) CS 기초(특히 ‘왜’에 대한 설명력)",
        "- 자료구조/알고리즘: 성능·복잡도를 말로 설명할 수 있어야 함",
        "- 네트워크/HTTP: 장애/지연의 원인을 추적할 수 있어야 함",
        "- 운영체제/동시성: 병목과 락/스레드 문제를 이해",
        "- DB/트랜잭션: 정합성/격리수준/인덱스 설계 감각",
        "",
        "### (2) 테스트/디버깅/관찰 가능성(Observability)",
        "- 단위/통합 테스트로 ‘의도’를 고정하는 능력",
        "- 로그/메트릭/트레이싱으로 ‘현실’을 보는 능력",
        "- 재현 가능한 버그 리포트 작성 능력(원인 추정 포함)",
        "",
        "### (3) 설계와 트레이드오프",
        "- 요구사항을 ‘기능/비기능’으로 분리해서 설계",
        "- 확장성 vs 단순함, 속도 vs 비용, 보안 vs 편의 같은 선택의 근거를 남기기",
        "",
        "### (4) 글쓰기(문서화)와 커뮤니케이션",
        "- 문제 정의/해결 과정을 문서로 남기면, 성장 속도가 빨라집니다.",
        "- AI에게도 “좋은 질문(맥락/제약/목표/예시)”을 주는 능력이 됩니다.",
        "",
        "---",
        "### 요약",
        "AI 시대의 자기개발은 ‘코딩 스킬’만이 아니라 문제 해결의 전 과정을 다루는 방향으로 가야 합니다.",
        "특히 위의 5단계를 ‘글로 쓰는 습관’으로 만들면, 실력이 빠르게 쌓입니다."
      ]
    },
    {
      "id": "programming-language-types",
      "title": "프로그래밍 언어의 종류(분류 방법 정리)",
      "date": "2026-02-10",
      "summary": "프로그래밍 언어는 ‘이름’이 아니라 분류 축(패러다임/추상화 수준/실행 방식/타입 시스템 등)으로 이해하면 빠르게 정리됩니다.",
      "category": "Coding/Theory",
      "tags": [
        "theory",
        "language",
        "basics"
      ],
      "content": [
        "## 왜 ‘종류’가 헷갈릴까",
        "언어는 한 가지로만 분류되지 않습니다. 예를 들어 JavaScript는 인터프리터 기반 + JIT + 동적 타입 + 함수형/객체지향 혼합처럼 여러 성격을 동시에 가질 수 있어요.",
        "",
        "그래서 언어를 외우기보다, 아래 ‘분류 축’을 알면 정리가 됩니다.",
        "",
        "## 1) 추상화 수준(레벨)",
        "- 저수준 언어: 하드웨어에 가깝고 제어가 세밀함 (예: C, 어셈블리)",
        "- 고수준 언어: 사람이 읽기 쉽고 생산성이 높음 (예: Python, Java, JavaScript)",
        "",
        "핵심은 “좋다/나쁘다”가 아니라 목표(성능/안전/생산성/이식성)에 따라 선택한다는 점입니다.",
        "",
        "## 2) 패러다임(프로그래밍 스타일)",
        "### (1) 절차적(Procedural)",
        "- 순서대로 명령을 실행하며 프로그램을 구성",
        "- 예: C",
        "",
        "### (2) 객체지향(OOP)",
        "- 데이터와 동작을 객체로 묶어 모델링",
        "- 예: Java, C#, (Python도 가능)",
        "",
        "### (3) 함수형(Functional)",
        "- 함수를 값처럼 다루고, 불변/순수함수에 친화적",
        "- 예: Haskell, (JavaScript/Scala도 일부 지원)",
        "",
        "### (4) 선언형(Declarative)",
        "- “어떻게”보다 “무엇을”을 표현",
        "- 예: SQL, HTML/CSS(프로그래밍 언어로 볼지 논쟁은 있지만 ‘선언형’의 대표 예시)",
        "",
        "대부분의 현대 언어는 멀티 패러다임입니다.",
        "",
        "## 3) 실행 방식(컴파일/인터프리트/JIT)",
        "- 컴파일 언어: 실행 전 기계어/바이트코드로 변환 (예: C/C++ → 기계어, Go/Rust 등)",
        "- 인터프리트 언어: 실행 중에 해석하며 동작 (예: Python(전통적 설명), Ruby 등)",
        "- JIT(Just-In-Time): 실행 중 자주 쓰는 부분을 최적화해 빠르게 실행 (예: Java JVM, JavaScript 엔진)",
        "",
        "요즘은 경계가 섞여서 “컴파일 vs 인터프리트”만으로 단정하기 어렵고, 런타임/VM을 함께 봐야 합니다.",
        "",
        "## 4) 타입 시스템(정적/동적, 강/약)",
        "- 정적 타입(Static): 컴파일 단계에서 타입 오류를 더 많이 잡음 (예: Java, C#, TypeScript)",
        "- 동적 타입(Dynamic): 실행 중 타입이 결정 (예: Python, JavaScript)",
        "",
        "또한 강/약 타입은 언어마다 정의가 애매할 수 있어, 실무에서는 보통",
        "- “자동 변환이 얼마나 일어나는가”",
        "- “런타임 타입 오류가 얼마나 빨리 드러나는가”",
        "정도로 경험적으로 이해하는 편이 좋습니다.",
        "",
        "## 5) 메모리 관리(수동/자동)",
        "- 수동 관리: 개발자가 직접 해제까지 책임 (예: C)",
        "- 자동 관리(GC): 가비지 컬렉터가 메모리를 정리 (예: Java, C#, Go(형태는 다름), JavaScript)",
        "",
        "GC는 편의성을 높이지만, 성능/지연(멈춤) 특성을 이해하고 써야 합니다.",
        "",
        "## 정리: 언어를 고르는 질문",
        "- 내가 해결하려는 문제는 무엇인가?",
        "- 성능/안전/생산성 중 무엇이 중요한가?",
        "- 팀/생태계(라이브러리, 배포, 운영)는 준비되어 있는가?",
        "",
        "---",
        "### 요약",
        "프로그래밍 언어의 ‘종류’는 하나의 표로 끝나지 않습니다.",
        "대신 분류 축(레벨/패러다임/실행 방식/타입/메모리 관리)을 기준으로 보면 어떤 언어도 빠르게 이해할 수 있습니다."
      ]
    },
    {
      "id": "orm-object-relational-mapping",
      "title": "ORM(Object-Relational Mapping) 정리",
      "date": "2026-02-10",
      "summary": "ORM은 객체(코드)와 관계형 DB(테이블) 사이를 매핑해 SQL을 ‘직접 다루는 부담’을 줄여주는 도구입니다. 편해지는 만큼, 성능/쿼리/트랜잭션 감각은 꼭 같이 가져가야 합니다.",
      "category": "Coding/Theory",
      "tags": [
        "theory",
        "db",
        "orm",
        "backend"
      ],
      "content": [
        "## ORM이란?",
        "ORM(Object-Relational Mapping)은 프로그램의 객체(클래스/인스턴스)를 DB의 테이블/행과 연결(매핑)해서, 데이터를 객체처럼 다룰 수 있게 해주는 기술/라이브러리입니다.",
        "",
        "쉽게 말하면:",
        "- DB에는 `users` 테이블이 있고",
        "- 코드에는 `User` 클래스가 있을 때",
        "- ORM이 둘 사이를 연결해 `User`를 저장/조회할 수 있게 해줍니다.",
        "",
        "## 왜 ORM을 쓸까",
        "- 생산성: CRUD를 빠르게 만들 수 있음",
        "- 유지보수: SQL 문자열을 여기저기 흩뿌리지 않게 됨",
        "- 안전성: 파라미터 바인딩/쿼리 빌더로 인젝션 위험을 줄임(그래도 설계가 중요)",
        "- 이식성(일부): DB가 바뀌어도 코드 변경을 줄일 수 있음(완전한 이식성은 기대하면 안 됨)",
        "",
        "## ORM이 해주는 것(대표 기능)",
        "- 매핑: 클래스 필드 ↔ 테이블 컬럼",
        "- 쿼리 생성: 조건/정렬/페이징 등",
        "- 변경 감지(Dirty Checking): 객체 수정 사항을 추적해 UPDATE를 생성",
        "- 관계 매핑: 1:N, N:1, N:M 등",
        "- 트랜잭션 단위 작업: 같은 트랜잭션에서 일관되게 처리하도록 도움",
        "",
        "## 대표 ORM 라이브러리/프레임워크(언어별)",
        "ORM은 언어/생태계마다 스타일이 달라요. 아래는 많이 쓰이는 선택지들입니다.",
        "",
        "### Java/Kotlin",
        "- JPA: 자바 ORM 표준(스펙) 자체 (구현체가 필요)",
        "- Hibernate: 가장 널리 쓰이는 JPA 구현체",
        "- Spring Data JPA: 리포지토리/쿼리 메서드 등으로 JPA 사용을 더 편하게",
        "",
        "### Python",
        "- Django ORM: Django에 포함된 ORM(Active Record 스타일)",
        "- SQLAlchemy: 파이썬에서 매우 널리 쓰이는 ORM/쿼리 빌더(강력한 표현력)",
        "- Peewee: 가볍고 단순한 ORM",
        "",
        "### JavaScript/TypeScript(Node.js)",
        "- Prisma: 스키마 기반 + 타입 생성 + 마이그레이션 경험이 좋은 편",
        "- TypeORM: 데코레이터 기반 ORM(프로젝트/버전에 따라 선호가 갈림)",
        "- Sequelize: 오래된 생태계, 다양한 DB 지원",
        "- MikroORM: Unit of Work/Identity Map 등 DDD 친화적 기능 강조",
        "",
        "### .NET(C#)",
        "- Entity Framework Core(EF Core): 대표적인 ORM",
        "- Dapper: 흔히 “마이크로 ORM”으로 불리며, SQL을 직접 쓰되 매핑을 편하게",
        "",
        "### Ruby",
        "- ActiveRecord(Rails): Rails의 기본 ORM",
        "",
        "### PHP",
        "- Eloquent(Laravel): Laravel의 기본 ORM",
        "- Doctrine ORM: PHP에서 널리 쓰이는 Data Mapper 스타일 ORM",
        "",
        "### Go",
        "- GORM: 가장 유명한 ORM 중 하나",
        "- 참고: `sqlc`는 ORM이라기보다 SQL을 기반으로 타입 안전한 코드를 생성하는 도구",
        "",
        "## ORM이 아닌데 함께 자주 언급되는 것",
        "- MyBatis(Java): ORM이라기보다 SQL Mapper에 가깝습니다. SQL을 직접 작성하고 매핑만 도와줍니다.",
        "",
        "## ORM을 쓸 때 꼭 알아야 하는 함정",
        "### 1) N+1 문제",
        "- 관계를 가진 데이터를 조회할 때, 예상보다 쿼리가 N번 추가로 나가는 문제",
        "- 해결 방향: 조인/페치 조인, eager/lazy 전략 이해, 쿼리 확인",
        "",
        "### 2) Lazy Loading(지연 로딩)과 트랜잭션 범위",
        "- 관계 데이터가 “필요할 때” 로딩되는데, 트랜잭션이 끝난 뒤 접근하면 오류가 날 수 있음",
        "- 해결 방향: 조회 시점 설계(필요한 데이터는 미리 로딩), 계층 분리 규칙 만들기",
        "",
        "### 3) ORM을 써도 SQL을 모르면 결국 막힌다",
        "- 인덱스, 조인, 실행 계획, 페이징 방식 같은 DB 기본기는 여전히 중요",
        "",
        "## 실무에서의 좋은 습관",
        "- 항상 쿼리를 확인: “내가 생각한 쿼리”가 실제로 나가는지 로그로 보기",
        "- 성능 기준을 정하기: 느려지는 지점은 대부분 ‘조회’에서 터짐",
        "- 도메인 모델과 조회 모델 분리도 고려: 복잡한 조회는 DTO/전용 쿼리로",
        "- 트랜잭션 경계를 명확히: 어디서 시작/끝나는지",
        "",
        "---",
        "### 요약",
        "ORM은 개발을 빠르게 해주지만, 그만큼 ‘쿼리가 보이지 않아서’ 성능 문제가 생기기 쉽습니다.",
        "따라서 ORM을 쓰더라도 SQL/인덱스/트랜잭션/조회 최적화 감각은 같이 키우는 게 중요합니다."
      ]
    },
    {
      "id": "springboot-jpa-hibernate",
      "title": "📚 JPA와 하이버네이트(Spring Boot에서 이해하기)",
      "date": "2026-02-10",
      "summary": "JPA는 ‘표준(스펙)’, Hibernate는 ‘대표 구현체’입니다. Spring Boot에서는 이 둘이 어떻게 연결되는지, 그리고 실무에서 어디가 자주 헷갈리는지 정리합니다.",
      "category": "Technology/SpringBoot",
      "tags": [
        "springboot",
        "jpa",
        "hibernate",
        "backend",
        "db"
      ],
      "content": [
        "## 한 줄 요약",
        "- JPA: 자바 ORM 표준(인터페이스/규약)",
        "- Hibernate: JPA를 구현한 구현체(라이브러리)",
        "- Spring Data JPA: JPA 사용을 더 편하게 만드는 스프링 모듈",
        "",
        "## Spring Boot에서의 구조(그림 대신 문장으로)",
        "- 애플리케이션 코드는 JPA(표준 API)를 사용",
        "- 실제 동작(쿼리 생성/실행)은 Hibernate가 담당",
        "- Spring Boot는 설정을 자동으로 구성(데이터소스/트랜잭션/엔티티매니저 등)",
        "",
        "## 왜 ‘JPA를 쓴다’고 말하지만 Hibernate가 보일까",
        "JPA는 표준이라서 “JPA만 설치”해선 실제로 동작하지 않습니다. 구현체가 필요하고, Spring Boot는 기본적으로 Hibernate를 많이 사용합니다.",
        "",
        "## 핵심 개념 4가지",
        "### 1) 영속성 컨텍스트(Persistence Context)",
        "- 엔티티를 관리하는 “1차 캐시 + 변경 감지 + 동일성 보장” 공간",
        "- 같은 트랜잭션 안에서 같은 id를 조회하면 같은 객체처럼 다뤄짐(동일성)",
        "",
        "### 2) 변경 감지(Dirty Checking)",
        "- 엔티티 필드를 바꾸면, 커밋 시점에 ORM이 UPDATE를 만들어 반영",
        "- 그래서 ‘save를 안 했는데 업데이트가 된다’ 같은 현상이 자연스러운 동작일 수 있음",
        "",
        "### 3) 지연 로딩(Lazy Loading)과 N+1",
        "- 관계 엔티티를 “필요할 때” 불러오는 방식이 흔함",
        "- 설계를 잘못하면 N+1 문제가 발생(조회 쿼리 폭증)",
        "",
        "### 4) 트랜잭션 경계(@Transactional)",
        "- JPA/Hibernate는 트랜잭션 범위에 강하게 의존",
        "- Lazy Loading이 트랜잭션 밖에서 터지는 이유도 대부분 여기서 발생",
        "",
        "## 실무 팁(꼭 해두면 좋은 것)",
        "- SQL 로그를 항상 확인: 내가 의도한 쿼리가 나가는지 보기",
        "- 조회는 특히 조심: 성능 문제는 대개 조회에서 터짐(조인/인덱스/페이징)",
        "- 복잡한 조회는 엔티티가 아니라 DTO/전용 쿼리로 분리하는 것도 전략",
        "- “JPA를 쓴다” = “SQL을 몰라도 된다”가 절대 아님",
        "",
        "---",
        "### 요약",
        "Spring Boot에서 JPA를 사용한다는 말은 보통 Hibernate를 통해 JPA 표준을 사용한다는 뜻입니다.",
        "그리고 성능/버그의 대부분은 트랜잭션, 지연 로딩, 쿼리에서 생기니 여기를 중심으로 공부하면 좋습니다."
      ]
    },
    {
      "id": "design-patterns-overview",
      "title": "디자인 패턴 정리(왜 쓰고, 어떻게 적용할까)",
      "date": "2026-02-10",
      "summary": "디자인 패턴은 ‘정답 템플릿’이 아니라, 반복되는 설계 문제를 더 읽기 쉽고 확장 가능하게 푸는 ‘이름 붙은 방법’입니다. 언제 쓰고 언제 피해야 하는지까지 같이 정리합니다.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "architecture",
        "oop"
      ],
      "content": [
        "## 디자인 패턴이란?",
        "디자인 패턴은 소프트웨어 설계에서 자주 반복되는 문제를 해결하는 재사용 가능한 설계 아이디어입니다.",
        "중요한 포인트는 ‘코드 조각’이 아니라 구조와 역할이라는 점이에요.",
        "",
        "## 왜 패턴을 배울까",
        "- 의사소통: “여기 팩토리로 빼자”처럼 짧게 합의 가능",
        "- 확장성: 기능 추가 시 수정 범위를 줄이는 데 도움",
        "- 테스트 용이성: 의존성 분리/역전으로 테스트가 쉬워짐",
        "- 복잡도 관리: 커지는 코드를 ‘역할’로 나누는 기준 제공",
        "",
        "## 패턴을 쓸 때의 주의점",
        "- 패턴은 도구입니다. 문제보다 패턴이 먼저 나오면 과설계가 됩니다.",
        "- “패턴 적용” 자체가 목표가 아니라, 변경에 강한 구조가 목표입니다.",
        "",
        "## 대표 분류(GoF: 생성/구조/행위)",
        "### 1) 생성(Creational) 패턴",
        "객체를 ‘어떻게 만들지’를 다룹니다.",
        "- Factory Method / Abstract Factory: 생성 로직을 분리해 교체/확장을 쉽게",
        "- Builder: 복잡한 객체를 단계적으로 생성(옵션이 많을 때 유용)",
        "- Singleton: 전역 1개 인스턴스(남용하면 테스트/결합도 문제)",
        "",
        "### 2) 구조(Structural) 패턴",
        "객체/클래스를 ‘어떻게 조합할지’를 다룹니다.",
        "- Adapter: 인터페이스를 맞춰서 붙이기(레거시/외부 라이브러리 연결)",
        "- Decorator: 기능을 덧붙이기(상속 대신 조합)",
        "- Facade: 복잡한 하위 시스템을 단순한 창구로 감싸기",
        "- Proxy: 실제 객체 접근을 제어(캐싱, 지연 로딩, 권한 등)",
        "",
        "### 3) 행위(Behavioral) 패턴",
        "객체가 ‘어떻게 협력할지’를 다룹니다.",
        "- Strategy: 알고리즘을 교체 가능하게(결제 방식, 정렬 방식 등)",
        "- Observer: 이벤트/구독 모델(상태 변화 알림)",
        "- Command: 요청을 객체로 캡슐화(실행/취소/재시도)",
        "- State: 상태에 따라 동작이 크게 달라질 때 조건문을 객체로 분리",
        "",
        "## 실무에서 ‘패턴’이 자연스럽게 쓰이는 순간",
        "- 조건문(`if/else` 또는 `switch`)이 계속 늘어날 때 → Strategy/State 고려",
        "- 생성 코드가 여기저기 복제될 때 → Factory/Builder 고려",
        "- 외부 API/라이브러리 교체 가능성을 남기고 싶을 때 → Adapter/Facade 고려",
        "- 기능을 조합해서 붙이고 싶을 때(로그, 인증, 캐싱) → Decorator/Proxy 고려",
        "",
        "## 패턴 적용 체크리스트(짧게)",
        "- 변경이 자주 일어나는 지점인가?",
        "- 역할/경계가 명확해지는가?",
        "- 테스트가 쉬워지는가?",
        "- 팀이 이해/유지할 수 있는 복잡도인가?",
        "",
        "---",
        "### 요약",
        "디자인 패턴은 ‘외우는 목록’이 아니라 변경에 강한 구조를 만드는 사고 도구입니다.",
        "문제를 먼저 정의하고, 그 다음에 패턴을 선택하면 과설계 없이도 큰 효과를 볼 수 있습니다."
      ]
    },
    {
      "id": "factory-method-pattern",
      "title": "디자인패턴-Factory Method(팩토리 메서드) + Java 예제",
      "date": "2026-02-10",
      "summary": "객체 생성 코드가 여기저기 퍼지고, 타입 분기가 늘어날 때 ‘생성 책임’을 한 곳으로 모으는 패턴이 Factory Method입니다. 생성은 서브클래스가, 사용은 상위 타입이 담당하게 만들 수 있어요.",
      "category": "Technology/Design-Pattern",
      "tags": [
        "theory",
        "design-pattern",
        "factory-method",
        "java",
        "oop"
      ],
      "content": [
        "## Factory Method란?",
        "Factory Method 패턴은 ‘객체를 생성하는 책임’을 별도의 메서드(팩토리 메서드)로 분리해서,",
        "클라이언트가 구체 클래스를 직접 `new` 하지 않도록 만드는 생성 패턴입니다.",
        "",
        "핵심은 이거예요:",
        "- 사용하는 쪽은 인터페이스(상위 타입)만 안다.",
        "- 무엇을 생성할지는 Creator(또는 그 서브클래스)가 결정한다.",
        "",
        "## 언제 필요할까",
        "- `if/else` 또는 `switch`로 타입을 나눠 `new` 하는 코드가 늘어난다",
        "- 생성 로직(기본값, 검증, 조립)이 반복된다",
        "- 같은 인터페이스를 구현한 다양한 구현체를 상황에 따라 바꿔 끼우고 싶다",
        "",
        "## 장점/단점(현실적으로)",
        "### 장점",
        "- 객체 생성 책임이 한 곳으로 모여 중복이 줄고, 변경에 강해짐",
        "- 클라이언트가 구체 타입에 덜 의존 → 테스트/확장이 쉬워짐",
        "",
        "### 단점",
        "- 클래스/구조가 늘어날 수 있음(작은 프로젝트에선 과할 수 있음)",
        "",
        "## Java 예제",
        "아래 예제는 “알림(Notification)”을 `EMAIL`/`SMS`로 생성하는 상황을 예로 듭니다.",
        "",
        "### 1) Product(인터페이스)와 ConcreteProduct",
        "```java",
        "interface Notification {",
        "    void send(String to, String message);",
        "}",
        "",
        "class EmailNotification implements Notification {",
        "    @Override",
        "    public void send(String to, String message) {",
        "        System.out.println(\"[EMAIL] to=\" + to + \" message=\" + message);",
        "    }",
        "}",
        "",
        "class SmsNotification implements Notification {",
        "    @Override",
        "    public void send(String to, String message) {",
        "        System.out.println(\"[SMS] to=\" + to + \" message=\" + message);",
        "    }",
        "}",
        "```",
        "",
        "### 2) Creator(팩토리 메서드 + 템플릿 메서드 느낌)",
        "```java",
        "abstract class NotificationService {",
        "    // Factory Method: 무엇을 만들지(구현체 선택)는 서브클래스가 결정",
        "    protected abstract Notification createNotification();",
        "",
        "    // 클라이언트가 호출하는 로직(공통 흐름)은 상위 클래스에 둔다",
        "    public void notify(String to, String message) {",
        "        // 공통 전처리/검증/로깅 등을 여기에 두기 좋다",
        "        if (to == null || to.isBlank()) throw new IllegalArgumentException(\"to is blank\");",
        "        if (message == null) message = \"\";",
        "",
        "        Notification notification = createNotification();",
        "        notification.send(to, message);",
        "    }",
        "}",
        "```",
        "",
        "### 3) ConcreteCreator",
        "```java",
        "class EmailNotificationService extends NotificationService {",
        "    @Override",
        "    protected Notification createNotification() {",
        "        return new EmailNotification();",
        "    }",
        "}",
        "",
        "class SmsNotificationService extends NotificationService {",
        "    @Override",
        "    protected Notification createNotification() {",
        "        return new SmsNotification();",
        "    }",
        "}",
        "```",
        "",
        "### 4) Client",
        "```java",
        "public class Main {",
        "    public static void main(String[] args) {",
        "        NotificationService service1 = new EmailNotificationService();",
        "        service1.notify(\"haru@example.com\", \"안녕하세요!\");",
        "",
        "        NotificationService service2 = new SmsNotificationService();",
        "        service2.notify(\"010-1234-5678\", \"문자 알림입니다.\");",
        "    }",
        "}",
        "```",
        "",
        "## 정리",
        "- Factory Method는 ‘new를 숨기는 패턴’이 아니라, 생성 책임을 분리해 변경에 강한 구조를 만드는 방법입니다.",
        "- 공통 흐름(검증/로깅/정책)은 상위 클래스에, 구현체 선택은 팩토리 메서드로 분리하면 깔끔해집니다."
      ]
    },
    {
      "id": "ai-ml-dl-overview",
      "title": "인공지능(AI), 약/강 인공지능, 머신러닝, 딥러닝 한 번에 정리",
      "date": "2026-02-10",
      "summary": "AI ⊃ 머신러닝 ⊃ 딥러닝 관계부터, 머신러닝의 지도/비지도/강화학습을 한 눈에 정리합니다.",
      "category": "Technology/AI",
      "tags": [
        "ai",
        "machine-learning",
        "deep-learning",
        "basics"
      ],
      "content": [
        "## 큰 그림(포함 관계)",
        "- 인공지능(AI): 사람의 ‘지능적 작업’을 기계가 수행하게 하는 넓은 영역",
        "- 머신러닝(ML): 데이터를 통해 규칙/패턴을 ‘학습’하게 만드는 AI의 한 분야",
        "- 딥러닝(DL): 신경망(특히 깊은 신경망)을 이용하는 머신러닝의 한 분야",
        "",
        "즉, 보통 이렇게 이해하면 됩니다:",
        "- AI ⊃ ML ⊃ DL",
        "",
        "## 인공지능(AI)",
        "AI는 문제를 풀기 위해 꼭 ‘학습’만 쓰지 않습니다.",
        "- 규칙 기반(전문가 시스템)",
        "- 탐색/계획(게임, 경로 탐색 등)",
        "- 최적화(스케줄링, 배치 등)",
        "- 머신러닝/딥러닝",
        "",
        "## 약인공지능(ANI) vs 강인공지능(AGI)",
        "### 약인공지능(ANI: Artificial Narrow Intelligence)",
        "- 특정 과제에 특화된 AI",
        "- 예: 스팸 필터, 번역, 추천 시스템, 이미지 분류, 음성 인식",
        "- 현재 현실에서 쓰이는 AI의 대부분이 ANI입니다.",
        "",
        "### 강인공지능(AGI: Artificial General Intelligence)",
        "- 사람처럼 다양한 영역에서 일반적인 문제 해결이 가능한 AI",
        "- 현실적으로는 아직 연구/가설 단계에 가까운 개념입니다.",
        "",
        "## 머신러닝(ML)",
        "머신러닝은 크게 지도학습 / 비지도학습 / 강화학습으로 나눠서 생각하면 편합니다.",
        "",
        "### 1) 지도학습(Supervised Learning)",
        "- 정답(라벨)이 있는 데이터로 학습",
        "- 목표: 입력 → 정답을 잘 맞히기",
        "- 예:",
        "  - 스팸/정상 분류(분류)",
        "  - 집값 예측(회귀)",
        "",
        "대표 알고리즘 예:",
        "- 선형 회귀, 로지스틱 회귀, 결정 트리, 랜덤 포레스트, SVM, 신경망 등",
        "",
        "### 2) 비지도학습(Unsupervised Learning)",
        "- 정답(라벨) 없이 데이터의 구조를 찾기",
        "- 목표: 군집/분포/차원 구조를 발견",
        "- 예:",
        "  - 고객 세그먼트 나누기(군집화)",
        "  - 차원 축소로 시각화/특징 추출(PCA 등)",
        "",
        "대표 알고리즘 예:",
        "- K-means, DBSCAN, PCA, 오토인코더 등",
        "",
        "### 3) 강화학습(Reinforcement Learning)",
        "- 에이전트가 환경에서 행동하고, 보상(reward)을 최대화하도록 학습",
        "- 목표: 장기 보상의 최적화(탐험 vs 활용)",
        "- 예:",
        "  - 게임 플레이(알파고류)",
        "  - 로봇 제어, 추천/광고의 정책 최적화",
        "",
        "핵심 용어:",
        "- 상태(state), 행동(action), 보상(reward), 정책(policy)",
        "",
        "## 딥러닝(DL)",
        "딥러닝은 신경망을 깊게 쌓아(다층) 복잡한 패턴을 학습합니다.",
        "- 이미지/음성/자연어처럼 ‘비정형 데이터’에서 강점을 보이는 경우가 많습니다.",
        "",
        "대표 모델/구조 예:",
        "- CNN(이미지), RNN/LSTM(시계열/문장), Transformer(자연어/범용)",
        "",
        "## 정리(실무 관점 질문)",
        "- 문제에 ‘학습’이 필요한가? 아니면 규칙/검색/최적화가 더 적절한가?",
        "- 라벨(정답)이 있는가? → 지도학습 가능",
        "- 라벨이 없다면 구조를 찾는가? → 비지도학습/표현학습",
        "- 행동의 연쇄와 보상이 핵심인가? → 강화학습",
        "",
        "---",
        "### 요약",
        "AI는 가장 넓은 개념이고, ML은 데이터로 학습하는 AI, DL은 신경망 기반 ML입니다.",
        "머신러닝은 지도/비지도/강화학습으로 나눠서 이해하면 대부분의 용어가 정리됩니다."
      ]
    },
    {
      "id": "prompt-engineering",
      "title": "프롬프트 엔지니어링(Prompt Engineering) 기초 정리",
      "date": "2026-02-10",
      "summary": "프롬프트 엔지니어링은 ‘말을 예쁘게 쓰는 기술’이 아니라, 모델이 올바른 출력에 도달하도록 목표·맥락·제약·검증을 설계하는 작업입니다.",
      "category": "Technology/AI",
      "tags": [
        "ai",
        "prompt",
        "llm",
        "basics"
      ],
      "content": [
        "## 프롬프트 엔지니어링이란?",
        "LLM(대규모 언어 모델)에게 원하는 결과를 얻기 위해 질문(프롬프트)을 구조화하고,",
        "맥락/제약/출력 형식/평가 기준을 명확히 설계하는 방법입니다.",
        "",
        "## 왜 중요한가",
        "- 같은 모델이라도 프롬프트에 따라 결과 품질이 크게 달라집니다.",
        "- ‘정답’이 아니라도, 일관성/재현성이 필요합니다.",
        "- 특히 실무에서는 “좋은 답”보다 안전하고 예측 가능한 답이 중요할 때가 많습니다.",
        "",
        "## 좋은 프롬프트의 기본 구성(템플릿)",
        "- 역할(Role): 너는 무엇을 하는가?",
        "- 목표(Goal): 무엇을 만들어야 하는가?",
        "- 맥락(Context): 필요한 배경 정보/데이터는 무엇인가?",
        "- 제약(Constraints): 금지/허용, 길이, 톤, 도구 사용, 언어 등",
        "- 출력 형식(Output format): JSON, 표, 불릿, 단계 등",
        "- 평가 기준(Eval): 무엇이 ‘좋은 결과’인지",
        "",
        "## 예시(간단 템플릿)",
        "```",
        "[역할] 너는 시니어 백엔드 개발자다.",
        "[목표] 아래 요구사항으로 API 설계안을 작성해라.",
        "[맥락] 서비스는 ... DB는 ... 트래픽은 ...",
        "[제약] 응답은 마크다운, 섹션은 Summary/Endpoints/Errors로 제한.",
        "[형식] 각 엔드포인트는 method/path/request/response 예시 포함.",
        "```",
        "",
        "## 자주 쓰는 기법들",
        "### 1) 예시 제공(Few-shot)",
        "- 원하는 출력 예시를 1~3개 보여주면 스타일/형식이 안정됩니다.",
        "",
        "### 2) 단계적 접근(체인처럼 쪼개기)",
        "- 한 번에 큰 일을 시키기보다,",
        "  - 요구사항 정리 → 설계 → 구현 → 테스트",
        "  같은 식으로 단계 분리하면 품질이 좋아집니다.",
        "",
        "### 3) 명확한 포맷 고정",
        "- JSON 스키마/마크다운 템플릿 등을 강하게 고정하면 후처리가 쉬워집니다.",
        "",
        "### 4) 금지 조건/안전 조건",
        "- 예: “추측하지 말고 모르면 모른다고 말하기”, “개인정보/비밀키는 출력하지 않기” 등",
        "",
        "## 흔한 실패 원인",
        "- 목표가 모호함(‘좋게’, ‘예쁘게’, ‘최적화’ 같은 표현만 있음)",
        "- 입력 데이터가 부족함(예시/제약/환경 정보가 없음)",
        "- 검증 기준이 없음(정답 판정이 불가)",
        "- 한 프롬프트에 너무 많은 일을 시킴",
        "",
        "## 실무에서의 추천 흐름",
        "1. 문제 정의: 무엇을 자동화/보조하려는가",
        "2. 입력/출력 정의: 어떤 데이터가 들어오고 무엇을 내보내야 하는가",
        "3. 제약 설정: 금지/허용/톤/길이/형식",
        "4. 평가: 좋은 결과/나쁜 결과 예시 만들기",
        "5. 반복 개선: 실패 케이스를 모아 프롬프트/가드레일 강화",
        "",
        "## 실무 예시: ChatGPT를 이렇게 활용한다",
        "아래 예시는 ‘그대로 복사해서’ 써도 되는 템플릿입니다. 중요한 건 “무엇을 원한다(완료 조건)”와 “입력(맥락)”을 같이 주는 거예요.",
        "",
        "### 1) 버그 원인 후보 좁히기(재현 정보 기반)",
        "```",
        "[역할] 너는 시니어 백엔드 개발자다.",
        "[목표] 아래 현상의 가능한 원인 Top 5를 우선순위로 정리하고, 각 원인을 검증하는 체크리스트를 제시해줘.",
        "[맥락] 환경: OS/런타임/버전… / 증상: … / 로그: … / 최근 변경: …",
        "[제약] 추측은 하되, 근거(왜 그런지)를 반드시 적어줘. 모르면 모른다고 말해줘.",
        "```",
        "",
        "### 2) 코드 리뷰 요청(안전/성능/가독성 관점)",
        "```",
        "[역할] 너는 코드리뷰어다.",
        "[목표] 아래 코드를 리뷰해서 (1) 버그 가능성 (2) 성능 병목 (3) 보안/예외 처리 (4) 리팩토링 제안을 각각 bullet로 작성해줘.",
        "[맥락] 이 코드는 ...에서 쓰이고, 트래픽은 ... 정도야.",
        "[제약] ‘왜’가 없는 지적은 하지 말고, 근거와 개선안을 같이 써줘.",
        "[입력] (코드 붙여넣기)",
        "```",
        "",
        "### 3) 문서/요약 자동화(회의/이슈 정리)",
        "```",
        "[역할] 너는 기술 PM이다.",
        "[목표] 아래 메모를 (1) 결정사항 (2) 미결정/리스크 (3) 액션아이템(담당/기한)으로 정리해줘.",
        "[제약] 액션아이템은 ‘완료 여부가 명확한 문장’으로 써줘.",
        "[입력] (회의 메모/슬랙 대화/이슈 내용)",
        "```",
        "",
        "### 4) 테스트 케이스 생성(엣지 케이스 중심)",
        "```",
        "[역할] 너는 QA 엔지니어다.",
        "[목표] 아래 기능 요구사항을 기반으로 테스트 케이스를 표로 만들어줘(정상/경계/오류/보안 포함).",
        "[맥락] 입력 스키마/제약/에러 코드…",
        "[형식] |케이스|입력|기대결과|비고|",
        "```",
        "",
        "### 5) ‘프롬프트’ 자체를 개선시키기(메타 프롬프트)",
        "```",
        "[목표] 내가 아래에 적은 프롬프트를 더 재현 가능하게 개선해줘.",
        "[제약] (1) 목표/제약/출력형식/평가기준을 분리해줘 (2) 필요한 질문 3개만 먼저 물어봐줘.",
        "[입력] (내 프롬프트)",
        "```",
        "",
        "## 실무에서 꼭 지킬 원칙 3가지",
        "- 비밀정보는 넣지 않기: API 키, 비밀번호, 개인 정보 등은 마스킹/제거",
        "- 출력 형식을 고정하기: 자동화할수록 형식(JSON/표/템플릿)이 중요",
        "- 검증 루프 만들기: 모델 답을 그대로 믿지 말고, 체크리스트/테스트로 검증",
        "",
        "---",
        "### 요약",
        "프롬프트 엔지니어링의 핵심은 명확한 목표와 제약, 그리고 평가 기준입니다.",
        "잘 설계하면 ‘운이 좋은 답’이 아니라 ‘재현 가능한 답’을 얻을 수 있습니다."
      ]
    }
  ]
}