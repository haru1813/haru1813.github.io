// file:// 로 열어도 동작하도록 posts 데이터를 전역에 제공합니다.
// 최신 데이터는 posts/posts.json 과 동일하게 유지하세요.
window.__POSTS__ = {
  "posts": [
    {
      "id": "ai-era-developer-growth",
      "title": "AI가 발전하는 시대, 개발자는 무엇을 자기개발해야 할까",
      "date": "2026-02-10",
      "summary": "코드를 ‘더 빨리’ 쓰는 것보다, 문제를 정의하고 해결하는 능력을 키우는 쪽으로 자기개발의 무게중심이 이동합니다.",
      "category": "Coding/Theory",
      "tags": ["theory", "career", "problem-solving"],
      "content": [
        "## 들어가며",
        "AI가 점점 더 많은 코드를 대신 작성해주는 시대가 오고 있습니다. 이럴수록 개발자의 가치는 “타이핑 속도”가 아니라 **문제를 제대로 정의하고, 올바른 해결책을 끝까지 완성하는 능력**에서 나옵니다.",
        "",
        "## 결론부터",
        "- AI가 잘하는 것: 빠른 초안 생성, 코드 변환, 반복 작업 자동화",
        "- 개발자가 계속 잘해야 하는 것: **문제 정의**, **우선순위**, **품질 기준**, **트레이드오프 판단**, **검증과 운영**",
        "",
        "## 문제의 정의 및 해결 5단계",
        "아래 5가지는 훈련으로 좋아집니다. 중요한 건 “머릿속”이 아니라 **글로 남기는 습관**이에요.",
        "",
        "### 1) 나의 자원과 상황을 파악하는 연습부터 한다",
        "- 지금 내가 가진 자원(시간/체력/돈/환경/도구/지식/협업 가능 여부)은 무엇인가?",
        "- 이번 문제에서 가장 큰 제약은 무엇인가? (마감, 성능, 품질, 보안, 유지보수, 학습 목적 등)",
        "- 오늘 가능한 최선은 무엇인가? (완벽 대신 “현실적 최적”)",
        "",
        "### 2) 목표를 “완료 여부가 명확하게” 정의하는 연습",
        "- 목표는 ‘성공/실패’를 분명히 판정할 수 있어야 합니다.",
        "- 나쁜 예: “성능 개선하기”, “좀 더 예쁘게 만들기”",
        "- 좋은 예: “LCP 2.5초 이하”, “배포 후 404 0건”, “로그인 성공률 99.9% 이상”",
        "",
        "### 3) 목표를 세부 단계로 쪼개는 훈련",
        "- 큰 목표를 **작은 작업 단위**로 나눕니다.",
        "- 각 단계는 ‘다음 행동’을 바로 할 수 있을 정도로 구체적이어야 합니다.",
        "- 예: 요구사항 정리 → 데이터/화면 설계 → 구현 → 테스트 → 배포 → 모니터링",
        "",
        "### 4) 발생할 문제를 미리 예측하는 연습",
        "- 실패 시나리오를 먼저 써봅니다.",
        "- 예: “권한이 꼬이면?”, “데이터가 비정상 값이면?”, “트래픽이 늘면?”, “배포 중 장애가 나면?”",
        "- 그리고 각각에 대해 최소한의 방어막(검증, 롤백, 로그, 알림)을 준비합니다.",
        "",
        "### 5) “그럼 어떻게 할지”를 글로 적는 연습",
        "- 마지막으로 실행 계획을 **짧은 문장**으로 씁니다.",
        "- 형식 예:",
        "- 오늘 할 일: …",
        "- 완료 조건: …",
        "- 리스크/대응: …",
        "- 다음 행동(바로 지금): …",
        "",
        "## 그럼 어떤 공부를 해야 할까",
        "AI가 코드를 도와줄수록, 아래 능력들이 더 중요해집니다.",
        "",
        "### (1) CS 기초(특히 ‘왜’에 대한 설명력)",
        "- 자료구조/알고리즘: 성능·복잡도를 말로 설명할 수 있어야 함",
        "- 네트워크/HTTP: 장애/지연의 원인을 추적할 수 있어야 함",
        "- 운영체제/동시성: 병목과 락/스레드 문제를 이해",
        "- DB/트랜잭션: 정합성/격리수준/인덱스 설계 감각",
        "",
        "### (2) 테스트/디버깅/관찰 가능성(Observability)",
        "- 단위/통합 테스트로 ‘의도’를 고정하는 능력",
        "- 로그/메트릭/트레이싱으로 ‘현실’을 보는 능력",
        "- 재현 가능한 버그 리포트 작성 능력(원인 추정 포함)",
        "",
        "### (3) 설계와 트레이드오프",
        "- 요구사항을 ‘기능/비기능’으로 분리해서 설계",
        "- 확장성 vs 단순함, 속도 vs 비용, 보안 vs 편의 같은 선택의 근거를 남기기",
        "",
        "### (4) 글쓰기(문서화)와 커뮤니케이션",
        "- 문제 정의/해결 과정을 문서로 남기면, 성장 속도가 빨라집니다.",
        "- AI에게도 “좋은 질문(맥락/제약/목표/예시)”을 주는 능력이 됩니다.",
        "",
        "---",
        "### 요약",
        "AI 시대의 자기개발은 ‘코딩 스킬’만이 아니라 **문제 해결의 전 과정**을 다루는 방향으로 가야 합니다.",
        "특히 위의 5단계를 ‘글로 쓰는 습관’으로 만들면, 실력이 빠르게 쌓입니다."
      ]
    },
    {
      "id": "programming-language-types",
      "title": "프로그래밍 언어의 종류(분류 방법 정리)",
      "date": "2026-02-10",
      "summary": "프로그래밍 언어는 ‘이름’이 아니라 분류 축(패러다임/추상화 수준/실행 방식/타입 시스템 등)으로 이해하면 빠르게 정리됩니다.",
      "category": "Coding/Theory",
      "tags": ["theory", "language", "basics"],
      "content": [
        "## 왜 ‘종류’가 헷갈릴까",
        "언어는 한 가지로만 분류되지 않습니다. 예를 들어 JavaScript는 **인터프리터 기반 + JIT + 동적 타입 + 함수형/객체지향 혼합**처럼 여러 성격을 동시에 가질 수 있어요.",
        "",
        "그래서 언어를 외우기보다, 아래 ‘분류 축’을 알면 정리가 됩니다.",
        "",
        "## 1) 추상화 수준(레벨)",
        "- **저수준 언어**: 하드웨어에 가깝고 제어가 세밀함 (예: C, 어셈블리)",
        "- **고수준 언어**: 사람이 읽기 쉽고 생산성이 높음 (예: Python, Java, JavaScript)",
        "",
        "핵심은 “좋다/나쁘다”가 아니라 **목표(성능/안전/생산성/이식성)**에 따라 선택한다는 점입니다.",
        "",
        "## 2) 패러다임(프로그래밍 스타일)",
        "### (1) 절차적(Procedural)",
        "- 순서대로 명령을 실행하며 프로그램을 구성",
        "- 예: C",
        "",
        "### (2) 객체지향(OOP)",
        "- 데이터와 동작을 객체로 묶어 모델링",
        "- 예: Java, C#, (Python도 가능)",
        "",
        "### (3) 함수형(Functional)",
        "- 함수를 값처럼 다루고, 불변/순수함수에 친화적",
        "- 예: Haskell, (JavaScript/Scala도 일부 지원)",
        "",
        "### (4) 선언형(Declarative)",
        "- “어떻게”보다 “무엇을”을 표현",
        "- 예: SQL, HTML/CSS(프로그래밍 언어로 볼지 논쟁은 있지만 ‘선언형’의 대표 예시)",
        "",
        "대부분의 현대 언어는 **멀티 패러다임**입니다.",
        "",
        "## 3) 실행 방식(컴파일/인터프리트/JIT)",
        "- **컴파일 언어**: 실행 전 기계어/바이트코드로 변환 (예: C/C++ → 기계어, Go/Rust 등)",
        "- **인터프리트 언어**: 실행 중에 해석하며 동작 (예: Python(전통적 설명), Ruby 등)",
        "- **JIT(Just-In-Time)**: 실행 중 자주 쓰는 부분을 최적화해 빠르게 실행 (예: Java JVM, JavaScript 엔진)",
        "",
        "요즘은 경계가 섞여서 “컴파일 vs 인터프리트”만으로 단정하기 어렵고, **런타임/VM**을 함께 봐야 합니다.",
        "",
        "## 4) 타입 시스템(정적/동적, 강/약)",
        "- **정적 타입(Static)**: 컴파일 단계에서 타입 오류를 더 많이 잡음 (예: Java, C#, TypeScript)",
        "- **동적 타입(Dynamic)**: 실행 중 타입이 결정 (예: Python, JavaScript)",
        "",
        "또한 강/약 타입은 언어마다 정의가 애매할 수 있어, 실무에서는 보통",
        "- “자동 변환이 얼마나 일어나는가”",
        "- “런타임 타입 오류가 얼마나 빨리 드러나는가”",
        "정도로 경험적으로 이해하는 편이 좋습니다.",
        "",
        "## 5) 메모리 관리(수동/자동)",
        "- **수동 관리**: 개발자가 직접 해제까지 책임 (예: C)",
        "- **자동 관리(GC)**: 가비지 컬렉터가 메모리를 정리 (예: Java, C#, Go(형태는 다름), JavaScript)",
        "",
        "GC는 편의성을 높이지만, 성능/지연(멈춤) 특성을 이해하고 써야 합니다.",
        "",
        "## 정리: 언어를 고르는 질문",
        "- 내가 해결하려는 문제는 무엇인가?",
        "- 성능/안전/생산성 중 무엇이 중요한가?",
        "- 팀/생태계(라이브러리, 배포, 운영)는 준비되어 있는가?",
        "",
        "---",
        "### 요약",
        "프로그래밍 언어의 ‘종류’는 하나의 표로 끝나지 않습니다.",
        "대신 **분류 축(레벨/패러다임/실행 방식/타입/메모리 관리)**을 기준으로 보면 어떤 언어도 빠르게 이해할 수 있습니다."
      ]
    },
    {
      "id": "orm-object-relational-mapping",
      "title": "ORM(Object-Relational Mapping) 정리",
      "date": "2026-02-10",
      "summary": "ORM은 객체(코드)와 관계형 DB(테이블) 사이를 매핑해 SQL을 ‘직접 다루는 부담’을 줄여주는 도구입니다. 편해지는 만큼, 성능/쿼리/트랜잭션 감각은 꼭 같이 가져가야 합니다.",
      "category": "Coding/Theory",
      "tags": ["theory", "db", "orm", "backend"],
      "content": [
        "## ORM이란?",
        "**ORM(Object-Relational Mapping)**은 프로그램의 **객체(클래스/인스턴스)**를 DB의 **테이블/행**과 연결(매핑)해서, 데이터를 객체처럼 다룰 수 있게 해주는 기술/라이브러리입니다.",
        "",
        "쉽게 말하면:",
        "- DB에는 `users` 테이블이 있고",
        "- 코드에는 `User` 클래스가 있을 때",
        "- ORM이 둘 사이를 연결해 `User`를 저장/조회할 수 있게 해줍니다.",
        "",
        "## 왜 ORM을 쓸까",
        "- **생산성**: CRUD를 빠르게 만들 수 있음",
        "- **유지보수**: SQL 문자열을 여기저기 흩뿌리지 않게 됨",
        "- **안전성**: 파라미터 바인딩/쿼리 빌더로 인젝션 위험을 줄임(그래도 설계가 중요)",
        "- **이식성(일부)**: DB가 바뀌어도 코드 변경을 줄일 수 있음(완전한 이식성은 기대하면 안 됨)",
        "",
        "## ORM이 해주는 것(대표 기능)",
        "- **매핑**: 클래스 필드 ↔ 테이블 컬럼",
        "- **쿼리 생성**: 조건/정렬/페이징 등",
        "- **변경 감지(Dirty Checking)**: 객체 수정 사항을 추적해 UPDATE를 생성",
        "- **관계 매핑**: 1:N, N:1, N:M 등",
        "- **트랜잭션 단위 작업**: 같은 트랜잭션에서 일관되게 처리하도록 도움",
        "",
        "## 대표 ORM 라이브러리/프레임워크(언어별)",
        "ORM은 언어/생태계마다 스타일이 달라요. 아래는 많이 쓰이는 선택지들입니다.",
        "",
        "### Java/Kotlin",
        "- **JPA**: 자바 ORM 표준(스펙) 자체 (구현체가 필요)",
        "- **Hibernate**: 가장 널리 쓰이는 JPA 구현체",
        "- **Spring Data JPA**: 리포지토리/쿼리 메서드 등으로 JPA 사용을 더 편하게",
        "",
        "### Python",
        "- **Django ORM**: Django에 포함된 ORM(Active Record 스타일)",
        "- **SQLAlchemy**: 파이썬에서 매우 널리 쓰이는 ORM/쿼리 빌더(강력한 표현력)",
        "- **Peewee**: 가볍고 단순한 ORM",
        "",
        "### JavaScript/TypeScript(Node.js)",
        "- **Prisma**: 스키마 기반 + 타입 생성 + 마이그레이션 경험이 좋은 편",
        "- **TypeORM**: 데코레이터 기반 ORM(프로젝트/버전에 따라 선호가 갈림)",
        "- **Sequelize**: 오래된 생태계, 다양한 DB 지원",
        "- **MikroORM**: Unit of Work/Identity Map 등 DDD 친화적 기능 강조",
        "",
        "### .NET(C#)",
        "- **Entity Framework Core(EF Core)**: 대표적인 ORM",
        "- **Dapper**: 흔히 “마이크로 ORM”으로 불리며, SQL을 직접 쓰되 매핑을 편하게",
        "",
        "### Ruby",
        "- **ActiveRecord(Rails)**: Rails의 기본 ORM",
        "",
        "### PHP",
        "- **Eloquent(Laravel)**: Laravel의 기본 ORM",
        "- **Doctrine ORM**: PHP에서 널리 쓰이는 Data Mapper 스타일 ORM",
        "",
        "### Go",
        "- **GORM**: 가장 유명한 ORM 중 하나",
        "- 참고: `sqlc`는 ORM이라기보다 SQL을 기반으로 타입 안전한 코드를 생성하는 도구",
        "",
        "## ORM이 아닌데 함께 자주 언급되는 것",
        "- **MyBatis**(Java): ORM이라기보다 **SQL Mapper**에 가깝습니다. SQL을 직접 작성하고 매핑만 도와줍니다.",
        "",
        "## ORM을 쓸 때 꼭 알아야 하는 함정",
        "### 1) N+1 문제",
        "- 관계를 가진 데이터를 조회할 때, 예상보다 쿼리가 **N번 추가**로 나가는 문제",
        "- 해결 방향: **조인/페치 조인**, eager/lazy 전략 이해, 쿼리 확인",
        "",
        "### 2) Lazy Loading(지연 로딩)과 트랜잭션 범위",
        "- 관계 데이터가 “필요할 때” 로딩되는데, 트랜잭션이 끝난 뒤 접근하면 오류가 날 수 있음",
        "- 해결 방향: 조회 시점 설계(필요한 데이터는 미리 로딩), 계층 분리 규칙 만들기",
        "",
        "### 3) ORM을 써도 SQL을 모르면 결국 막힌다",
        "- 인덱스, 조인, 실행 계획, 페이징 방식 같은 DB 기본기는 여전히 중요",
        "",
        "## 실무에서의 좋은 습관",
        "- **항상 쿼리를 확인**: “내가 생각한 쿼리”가 실제로 나가는지 로그로 보기",
        "- **성능 기준을 정하기**: 느려지는 지점은 대부분 ‘조회’에서 터짐",
        "- **도메인 모델과 조회 모델 분리**도 고려: 복잡한 조회는 DTO/전용 쿼리로",
        "- **트랜잭션 경계**를 명확히: 어디서 시작/끝나는지",
        "",
        "---",
        "### 요약",
        "ORM은 개발을 빠르게 해주지만, 그만큼 ‘쿼리가 보이지 않아서’ 성능 문제가 생기기 쉽습니다.",
        "따라서 ORM을 쓰더라도 **SQL/인덱스/트랜잭션/조회 최적화** 감각은 같이 키우는 게 중요합니다."
      ]
    }
  ]
};

