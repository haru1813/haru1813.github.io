<script setup>
import ArticleHeader from '@/components/ArticleHeader.vue'
import ArticleBody from '@/components/ArticleBody.vue'

const post = {
  id: "design-patterns-overview",
  title: "디자인 패턴 정리(왜 쓰고, 어떻게 적용할까)",
  date: "2026-02-10",
  summary: "디자인 패턴은 ‘정답 템플릿’이 아니라, 반복되는 설계 문제를 더 읽기 쉽고 확장 가능하게 푸는 ‘이름 붙은 방법’입니다. 언제 쓰고 언제 피해야 하는지까지 같이 정리합니다.",
  category: "Technology/Design-Pattern",
  tags: ["theory","design-pattern","architecture","oop"],
  content: ["## 디자인 패턴이란?", "디자인 패턴은 소프트웨어 설계에서 자주 반복되는 문제를 해결하는 재사용 가능한 설계 아이디어입니다.", "중요한 포인트는 ‘코드 조각’이 아니라 구조와 역할이라는 점이에요.", "", "## 왜 패턴을 배울까", "- 의사소통: “여기 팩토리로 빼자”처럼 짧게 합의 가능", "- 확장성: 기능 추가 시 수정 범위를 줄이는 데 도움", "- 테스트 용이성: 의존성 분리/역전으로 테스트가 쉬워짐", "- 복잡도 관리: 커지는 코드를 ‘역할’로 나누는 기준 제공", "", "## 패턴을 쓸 때의 주의점", "- 패턴은 도구입니다. 문제보다 패턴이 먼저 나오면 과설계가 됩니다.", "- “패턴 적용” 자체가 목표가 아니라, 변경에 강한 구조가 목표입니다.", "", "## 대표 분류(GoF: 생성/구조/행위)", "### 1) 생성(Creational) 패턴", "객체를 ‘어떻게 만들지’를 다룹니다.", "- Factory Method / Abstract Factory: 생성 로직을 분리해 교체/확장을 쉽게", "- Builder: 복잡한 객체를 단계적으로 생성(옵션이 많을 때 유용)", "- Singleton: 전역 1개 인스턴스(남용하면 테스트/결합도 문제)", "", "### 2) 구조(Structural) 패턴", "객체/클래스를 ‘어떻게 조합할지’를 다룹니다.", "- Adapter: 인터페이스를 맞춰서 붙이기(레거시/외부 라이브러리 연결)", "- Decorator: 기능을 덧붙이기(상속 대신 조합)", "- Facade: 복잡한 하위 시스템을 단순한 창구로 감싸기", "- Proxy: 실제 객체 접근을 제어(캐싱, 지연 로딩, 권한 등)", "", "### 3) 행위(Behavioral) 패턴", "객체가 ‘어떻게 협력할지’를 다룹니다.", "- Strategy: 알고리즘을 교체 가능하게(결제 방식, 정렬 방식 등)", "- Observer: 이벤트/구독 모델(상태 변화 알림)", "- Command: 요청을 객체로 캡슐화(실행/취소/재시도)", "- State: 상태에 따라 동작이 크게 달라질 때 조건문을 객체로 분리", "", "## 실무에서 ‘패턴’이 자연스럽게 쓰이는 순간", "- 조건문(`if/else` 또는 `switch`)이 계속 늘어날 때 → Strategy/State 고려", "- 생성 코드가 여기저기 복제될 때 → Factory/Builder 고려", "- 외부 API/라이브러리 교체 가능성을 남기고 싶을 때 → Adapter/Facade 고려", "- 기능을 조합해서 붙이고 싶을 때(로그, 인증, 캐싱) → Decorator/Proxy 고려", "", "## 패턴 적용 체크리스트(짧게)", "- 변경이 자주 일어나는 지점인가?", "- 역할/경계가 명확해지는가?", "- 테스트가 쉬워지는가?", "- 팀이 이해/유지할 수 있는 복잡도인가?", "", "---", "### 요약", "디자인 패턴은 ‘외우는 목록’이 아니라 변경에 강한 구조를 만드는 사고 도구입니다.", "문제를 먼저 정의하고, 그 다음에 패턴을 선택하면 과설계 없이도 큰 효과를 볼 수 있습니다."]
}
</script>

<template>
  <ArticleHeader :post="post" />
  <ArticleBody :content="post.content" />
</template>
