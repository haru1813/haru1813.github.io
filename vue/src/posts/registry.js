// Auto-generated from posts.json
import Post_solid_overview from './solid-overview.vue'
import Post_mount_overview from './mount-overview.vue'
import Post_ssh_overview from './ssh-overview.vue'
import Post_git_overview from './git-overview.vue'
import Post_docker_core_concepts from './docker-core-concepts.vue'
import Post_solid_srp from './solid-srp.vue'
import Post_solid_ocp from './solid-ocp.vue'
import Post_solid_lsp from './solid-lsp.vue'
import Post_solid_isp from './solid-isp.vue'
import Post_solid_dip from './solid-dip.vue'
import Post_container_image_relationship from './container-image-relationship.vue'
import Post_docker_hub from './docker-hub.vue'
import Post_docker_pros_cons_use_cases from './docker-pros-cons-use-cases.vue'
import Post_docker_desktop from './docker-desktop.vue'
import Post_docker_vs_virtualization from './docker-vs-virtualization.vue'
import Post_container_os_reality from './container-os-reality.vue'
import Post_engine_in_software from './engine-in-software.vue'
import Post_server_overview from './server-overview.vue'
import Post_python_print from './python-print.vue'
import Post_abstract_factory_pattern from './abstract-factory-pattern.vue'
import Post_builder_pattern from './builder-pattern.vue'
import Post_singleton_pattern from './singleton-pattern.vue'
import Post_adapter_pattern from './adapter-pattern.vue'
import Post_decorator_pattern from './decorator-pattern.vue'
import Post_facade_pattern from './facade-pattern.vue'
import Post_proxy_pattern from './proxy-pattern.vue'
import Post_strategy_pattern from './strategy-pattern.vue'
import Post_observer_pattern from './observer-pattern.vue'
import Post_command_pattern from './command-pattern.vue'
import Post_state_pattern from './state-pattern.vue'
import Post_hello_pages from './hello-pages.vue'
import Post_ai_era_developer_growth from './ai-era-developer-growth.vue'
import Post_programming_language_types from './programming-language-types.vue'
import Post_orm_object_relational_mapping from './orm-object-relational-mapping.vue'
import Post_springboot_jpa_hibernate from './springboot-jpa-hibernate.vue'
import Post_springboot_rest_api from './springboot-rest-api.vue'
import Post_springboot_security_jwt from './springboot-security-jwt.vue'
import Post_springboot_webflux from './springboot-webflux.vue'
import Post_springboot_actuator from './springboot-actuator.vue'
import Post_springboot_docker from './springboot-docker.vue'
import Post_springboot_configuration from './springboot-configuration.vue'
import Post_springboot_test from './springboot-test.vue'
import Post_springboot_annotations from './springboot-annotations.vue'
import Post_springboot_request_response from './springboot-request-response.vue'
import Post_thymeleaf_overview from './thymeleaf-overview.vue'
import Post_design_patterns_overview from './design-patterns-overview.vue'
import Post_factory_method_pattern from './factory-method-pattern.vue'
import Post_ai_ml_dl_overview from './ai-ml-dl-overview.vue'
import Post_prompt_engineering from './prompt-engineering.vue'
import Post_accounting_overview from './accounting-overview.vue'
import Post_financial_statements from './financial-statements.vue'
import Post_income_statement_vs_balance_sheet from './income-statement-vs-balance-sheet.vue'
import Post_debit_credit from './debit-credit.vue'
import Post_assets_liabilities_equity from './assets-liabilities-equity.vue'
import Post_financial_accounting from './financial-accounting.vue'
import Post_management_accounting from './management-accounting.vue'
import Post_balance_sheet_guide from './balance-sheet-guide.vue'
import Post_income_statement_guide from './income-statement-guide.vue'
import Post_cash_flow_statement_guide from './cash-flow-statement-guide.vue'
import Post_statement_of_changes_in_equity_guide from './statement-of-changes-in-equity-guide.vue'
import Post_notes_to_financial_statements_guide from './notes-to-financial-statements-guide.vue'
import Post_stock_overview from './stock-overview.vue'
import Post_stock_market_and_brokerage from './stock-market-and-brokerage.vue'
import Post_stock_price_basics from './stock-price-basics.vue'
import Post_stock_investment_terms from './stock-investment-terms.vue'
import Post_stock_investment_basics from './stock-investment-basics.vue'
import Post_economics_overview from './economics-overview.vue'
import Post_gdp_and_economic_growth from './gdp-and-economic-growth.vue'
import Post_inflation_and_prices from './inflation-and-prices.vue'
import Post_interest_rates_and_monetary_policy from './interest-rates-and-monetary-policy.vue'
import Post_exchange_rate_basics from './exchange-rate-basics.vue'
import Post_economic_indicators_basics from './economic-indicators-basics.vue'
import Post_seed_money_basics from './seed-money-basics.vue'
import Post_tax_overview from './tax-overview.vue'
import Post_income_tax_basics from './income-tax-basics.vue'
import Post_four_big_insurance_and_tax from './four-big-insurance-and-tax.vue'
import Post_tax_deductions_basics from './tax-deductions-basics.vue'
import Post_year_end_tax_settlement_basics from './year-end-tax-settlement-basics.vue'
import Post_vat_basics from './vat-basics.vue'
import Post_real_estate_overview from './real-estate-overview.vue'
import Post_real_estate_transaction_basics from './real-estate-transaction-basics.vue'
import Post_apartment_terms from './apartment-terms.vue'
import Post_real_estate_loan_basics from './real-estate-loan-basics.vue'
import Post_jeonse_and_monthly_rent from './jeonse-and-monthly-rent.vue'
import Post_real_estate_tax_basics from './real-estate-tax-basics.vue'
import Post_registry_reading_guide from './registry-reading-guide.vue'
import Post_finance_overview from './finance-overview.vue'
import Post_banks_and_financial_institutions from './banks-and-financial-institutions.vue'
import Post_deposits_and_savings from './deposits-and-savings.vue'
import Post_interest_basics from './interest-basics.vue'
import Post_credit_and_credit_rating from './credit-and-credit-rating.vue'
import Post_loan_basics from './loan-basics.vue'
import Post_securities_basics from './securities-basics.vue'
import Post_financial_regulators_overview from './financial-regulators-overview.vue'
import Post_law_overview from './law-overview.vue'
import Post_civil_law_basics from './civil-law-basics.vue'
import Post_criminal_law_basics from './criminal-law-basics.vue'
import Post_labor_law_basics from './labor-law-basics.vue'
import Post_contract_basics from './contract-basics.vue'
import Post_legal_system_overview from './legal-system-overview.vue'
import Post_korea_three_branches from './korea-three-branches.vue'
import Post_korea_adult_resident_id from './korea-adult-resident-id.vue'
import Post_korea_adult_voting from './korea-adult-voting.vue'
import Post_korea_adult_government_services from './korea-adult-government-services.vue'
import Post_korea_adult_four_basic_duties from './korea-adult-four-basic-duties.vue'
import Post_korea_adult_citizen_rights_duties from './korea-adult-citizen-rights-duties.vue'
import Post_korea_adult_seal_notarization from './korea-adult-seal-notarization.vue'

const meta_solid_overview = { id: "solid-overview", title: "SOLID 원칙 개요", date: "2026-02-11", summary: "SOLID는 객체지향 설계의 5가지 핵심 원칙입니다. Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion를 한눈에 정리합니다.", category: "Technology/SOLID", tags: ["theory","solid","oop","design-principles"], content: ["## SOLID란?", "SOLID는 로버트 C. 마틴(Robert C. Martin)이 정리한 객체지향 설계의 5가지 핵심 원칙의 머리글자입니다.", "", "| 원칙 | 영어 | 한글 | 한 줄 요약 |", "|------|------|------|------------|", "| S | Single Responsibility | 단일 책임 | 한 클래스는 하나의 변경 이유만 |", "| O | Open/Closed | 개방-폐쇄 | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 |", "| L | Liskov Substitution | 리스코프 치환 | 하위 타입은 상위 타입을 대체 가능해야 함 |", "| I | Interface Segregation | 인터페이스 분리 | 사용하지 않는 메서드에 의존하지 말 것 |", "| D | Dependency Inversion | 의존성 역전 | 구체가 아니라 추상에 의존할 것 |", "", "## 왜 SOLID를 지킬까", "- 유지보수성: 변경 범위를 줄이고, 버그를 줄임", "- 테스트 용이성: 의존성 분리/역전으로 테스트가 쉬워짐", "- 확장성: 새 기능 추가 시 기존 코드 수정 최소화", "", "---", "### 요약", "SOLID는 변경에 강한 설계를 위한 5가지 원칙입니다. SRP, OCP, LSP, ISP, DIP를 순서대로 익히면 좋습니다."] }
const meta_mount_overview = { id: "mount-overview", title: "마운트(Mount)란?", date: "2026-02-11", summary: "마운트는 저장 장치·파일시스템을 특정 경로(마운트 포인트)에 연결해 접근 가능하게 만드는 것입니다. Linux mount/umount, Windows 드라이브 문자, Docker 볼륨까지 정리합니다.", category: "Coding/Theory", tags: ["theory","mount","filesystem","linux","docker","storage"], content: ["## 한 줄 요약", "마운트(Mount)는 저장 장치나 파일시스템을 디렉터리 트리의 특정 경로에 붙여서 파일처럼 접근할 수 있게 만드는 것입니다.", "", "## 마운트란?", "컴퓨터에는 디스크, USB, 네트워크 공유 폴더 등 여러 저장 공간이 있습니다. 이들을 어디서 접근할지 정해 주는 것이 마운트입니다.", "", "- 마운트 포인트(Mount Point): 파일시스템이 붙는 디렉터리 경로", "- 마운트: 특정 경로에 저장 공간을 연결하는 행위", "- 언마운트(Unmount): 연결을 끊는 행위", "", "## Linux에서의 마운트", "```bash", "mount /dev/sdb1 /mnt/usb", "umount /mnt/usb", "mount", "df -h", "```", "", "### /etc/fstab", "시스템 부팅 시 자동으로 마운트하려면 /etc/fstab에 등록합니다.", "", "### bind mount", "이미 있는 디렉터리를 다른 경로에서도 보이게 할 때 사용합니다.", "", "```bash", "mount --bind /원본/경로 /다른/경로", "```", "", "## Windows에서의 마운트", "Windows는 드라이브 문자(C:, D:, E: 등)로 접근합니다. 새 디스크·USB를 꽂으면 자동 할당됩니다.", "", "## Docker에서의 마운트", "| 방식 | 설명 | 예시 |", "|------|------|------|", "| 볼륨 마운트 | 도커가 관리하는 볼륨을 컨테이너에 연결 | -v myvol:/app/data |", "| 바인드 마운트 | 호스트의 특정 경로를 그대로 연결 | -v /data:/app/data |", "", "---", "### 요약", "마운트는 디스크·USB·네트워크 공유·도커 볼륨을 특정 경로에 연결해 파일처럼 접근하게 만드는 것입니다."] }
const meta_ssh_overview = { id: "ssh-overview", title: "SSH(Secure Shell)란?", date: "2026-02-11", summary: "SSH는 네트워크를 통해 원격 컴퓨터에 안전하게 접속하거나 파일을 전송하는 프로토콜입니다. ssh, scp, sftp, 공개키 인증 등 핵심 개념을 정리합니다.", category: "Coding/Theory", tags: ["theory","ssh","security","network","remote"], content: ["## 한 줄 요약", "SSH(Secure Shell)는 네트워크를 통해 원격 컴퓨터에 암호화된 통신으로 접속하는 프로토콜입니다. 비밀번호 대신 키 기반 인증을 쓰면 더 안전합니다.", "", "## 주요 용도", "| 용도 | 설명 |", "|------|------|", "| 원격 로그인 | 서버에 ssh user@host로 접속해 명령 실행 |", "| 파일 전송 | scp, sftp로 암호화된 파일 송수신 |", "| Git·배포 | GitHub 등에 SSH 키로 인증, CI/CD에서 서버 접속 |", "", "## 기본 사용법", "", "### 원격 접속(ssh)", "```bash", "ssh user@hostname", "ssh -p 2222 user@hostname", "ssh -i ~/.ssh/my_key user@hostname", "```", "", "### 파일 전송(scp)", "```bash", "scp file.txt user@host:/path/to/dest", "scp user@host:/path/to/file.txt .", "scp -r ./mydir user@host:/path/", "```", "", "### SFTP", "```bash", "sftp user@host", "```", "", "## SSH 키 인증", "비밀번호 대신 공개키/비밀키 쌍으로 인증하면 더 안전합니다.", "", "```bash", "ssh-keygen -t ed25519", "ssh-copy-id user@host", "```", "", "## 클라이언트 설정(~/.ssh/config)", "```", "Host myserver", "    HostName 192.168.1.100", "    User deploy", "    IdentityFile ~/.ssh/my_key", "    Port 22", "```", "", "이후 ssh myserver만 입력해 접속 가능.", "", "---", "### 요약", "SSH는 원격 컴퓨터에 안전하게 접속하거나 파일을 전송하는 프로토콜입니다. ssh, scp, sftp를 쓰고, 공개키 인증으로 보안을 강화할 수 있습니다."] }
const meta_git_overview = { id: "git-overview", title: "Git이란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "Git은 코드의 변경 이력을 관리하는 도구입니다. 왜 쓰는지, 저장소·커밋·브랜치가 뭔지 처음 Git을 접하는 사람 눈높이로 정리합니다.", category: "Technology/Git", tags: ["git","버전관리","기초","입문"], content: ["Git 입문 글입니다."] }
const meta_docker_core_concepts = { id: "docker-core-concepts", title: "도커 핵심 개념: 도커, 컨테이너, 도커 엔진, 이미지", date: "2026-02-11", summary: "도커(Docker)와 컨테이너, 도커 엔진, 이미지의 개념과 이들 간의 관계를 정리합니다.", category: "Technology/Docker", tags: ["docker","container","image","engine","devops"], content: ["## 한 줄 요약", "- 도커: 컨테이너 기반 앱을 실행·배포하는 플랫폼", "- 컨테이너: 격리된 실행 환경", "- 도커 엔진: 컨테이너를 생성·실행·관리하는 핵심 프로그램", "- 이미지: 컨테이너를 만들기 위한 읽기 전용 템플릿", "", "## 관계", "이미지 → 도커 엔진 → 컨테이너 생성·실행", "", "## 도커 엔진 구성", "| 구성요소 | 역할 |", "|----------|------|", "| dockerd | 데몬, 이미지 받아와 컨테이너 생성·실행·관리 |", "| containerd | 컨테이너 런타임 관리 |", "| runc | 실제 컨테이너 프로세스 생성 |", "", "---", "### 요약", "도커는 이미지로 컨테이너를 만들고, 도커 엔진(dockerd, containerd, runc)이 이를 관리합니다."] }
const meta_solid_srp = { id: "solid-srp", title: "SOLID-Single Responsibility Principle(단일 책임 원칙)", date: "2026-02-11", summary: "단일 책임 원칙(SRP)은 한 클래스가 하나의 변경 이유만 가져야 한다는 원칙입니다.", category: "Technology/SOLID", tags: ["theory","solid","srp","oop"], content: ["## SRP란?", "Single Responsibility Principle(단일 책임 원칙)은 한 클래스가 하나의 책임만, 즉 하나의 변경 이유만 가져야 한다는 원칙입니다.", "", "## 위반 예시", "User 클래스가 사용자 정보 저장 + 이메일 발송 + 로그 기록을 모두 담당하면 SRP 위반입니다.", "", "```java", "public class User {", "    public void save() { /* DB 저장 */ }", "    public void sendEmail() { /* 이메일 발송 */ }", "    public void log() { /* 로그 기록 */ }", "}", "```", "", "## 개선 예시", "```java", "public class User { /* 데이터만 */ }", "public class UserRepository { public void save(User u) { } }", "public class EmailService { public void send(User u, String msg) { } }", "```", "", "---", "### 요약", "SRP는 하나의 클래스가 하나의 변경 이유만 가지도록 책임을 분리하는 원칙입니다."] }
const meta_solid_ocp = { id: "solid-ocp", title: "SOLID-Open/Closed Principle(개방-폐쇄 원칙)", date: "2026-02-11", summary: "개방-폐쇄 원칙(OCP)은 확장에는 열려 있고, 수정에는 닫혀 있어야 한다는 원칙입니다.", category: "Technology/SOLID", tags: ["theory","solid","ocp","oop"], content: ["## OCP란?", "Open/Closed Principle(개방-폐쇄 원칙)은 소프트웨어 요소는 확장에는 열려 있으나 수정에는 닫혀 있어야 한다는 원칙입니다.", "", "## 요약", "새 기능 추가 시 기존 코드를 수정하지 않고, 확장(새 클래스/인터페이스 구현)으로 처리합니다."] }
const meta_solid_lsp = { id: "solid-lsp", title: "SOLID-Liskov Substitution Principle(리스코프 치환 원칙)", date: "2026-02-11", summary: "리스코프 치환 원칙(LSP)은 하위 타입이 상위 타입을 대체했을 때 프로그램의 정확성이 깨지지 않아야 한다는 원칙입니다.", category: "Technology/SOLID", tags: ["theory","solid","lsp","oop"], content: ["## LSP란?", "Liskov Substitution Principle(리스코프 치환 원칙)은 하위 타입은 상위 타입을 대체했을 때, 프로그램의 정확성이 깨지지 않아야 한다는 원칙입니다.", "", "## 위반 예시", "Rectangle을 상속한 Square가 setWidth/setHeight 시 상위 타입과 다르게 동작하는 경우.", "", "## 개선 예시", "Square가 Rectangle을 상속하지 않고, 공통 인터페이스 Shape로 분리하면 LSP를 지킬 수 있습니다.", "", "---", "### 요약", "LSP는 하위 타입이 상위 타입의 계약을 지켜야 한다는 원칙입니다."] }
const meta_solid_isp = { id: "solid-isp", title: "SOLID-Interface Segregation Principle(인터페이스 분리 원칙)", date: "2026-02-11", summary: "인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 메서드에 의존하지 않아야 한다는 원칙입니다.", category: "Technology/SOLID", tags: ["theory","solid","isp","oop"], content: ["## ISP란?", "Interface Segregation Principle(인터페이스 분리 원칙)은 클라이언트는 자신이 사용하지 않는 메서드에 의존해서는 안 된다는 원칙입니다.", "", "큰 인터페이스 하나보다, 작고 구체적인 인터페이스 여러 개가 낫습니다.", "", "---", "### 요약", "ISP는 클라이언트별로 필요한 메서드만 노출하는 원칙입니다."] }
const meta_solid_dip = { id: "solid-dip", title: "SOLID-Dependency Inversion Principle(의존성 역전 원칙)", date: "2026-02-11", summary: "의존성 역전 원칙(DIP)은 구체가 아니라 추상에 의존해야 한다는 원칙입니다.", category: "Technology/SOLID", tags: ["theory","solid","dip","oop"], content: ["## DIP란?", "Dependency Inversion Principle(의존성 역전 원칙)은 고수준 모듈은 저수준 모듈에 의존하면 안 되며, 둘 다 추상화에 의존해야 한다는 원칙입니다.", "", "---", "### 요약", "DIP는 구체가 아니라 추상(인터페이스, 추상클래스)에 의존하라는 원칙입니다."] }
const meta_container_image_relationship = { id: "container-image-relationship", title: "컨테이너와 이미지의 관계", date: "2026-02-11", summary: "이미지는 읽기 전용 템플릿, 컨테이너는 그 이미지로부터 생성된 실행 인스턴스입니다.", category: "Technology/Docker", tags: ["docker","container","image","relationship","layers"], content: ["## 한 줄 요약", "- 이미지: 컨테이너를 만들기 위한 읽기 전용 템플릿", "- 컨테이너: 이미지를 기반으로 생성된, 실행 중인 인스턴스", "", "## 클래스와 객체 비유", "| 개념 | 프로그래밍 비유 |", "|------|-----------------|", "| 이미지 | 클래스(설계도) |", "| 컨테이너 | 객체(인스턴스) |", "", "다만 docker commit으로 컨테이너 → 이미지가 가능해 경계가 일방향만은 아닙니다.", "", "## 핵심 정리", "- 이미지가 있으면 컨테이너를 만들 수 있음", "- 같은 이미지 → 여러 컨테이너(1:N)", "", "---", "### 요약", "이미지는 읽기 전용 템플릿, 컨테이너는 그 이미지로부터 만들어진 실행 인스턴스입니다."] }
const meta_docker_hub = { id: "docker-hub", title: "도커 허브(Docker Hub)란?", date: "2026-02-11", summary: "Docker Hub는 도커 이미지를 저장·공유하는 공식 레지스트리 서비스입니다.", category: "Technology/Docker", tags: ["docker","docker-hub","registry","image","pull","push"], content: ["## 한 줄 요약", "Docker Hub는 도커 이미지를 저장·공유하는 클라우드 레지스트리입니다. GitHub가 코드를, Docker Hub는 이미지를 호스팅합니다.", "", "## 주요 기능", "| 기능 | 설명 |", "|------|------|", "| pull | docker pull로 이미지 받기 |", "| push | docker push로 이미지 올리기 |", "| 공개/비공개 | 저장소 공개 여부 설정 |", "", "---", "### 요약", "Docker Hub는 docker pull, docker push의 기본 대상 레지스트리입니다."] }
const meta_docker_pros_cons_use_cases = { id: "docker-pros-cons-use-cases", title: "도커의 장점, 단점, 용도", date: "2026-02-11", summary: "도커의 장점(일관된 환경, 빠른 배포 등), 단점(보안·디버깅 한계 등), 적합한 용도를 정리합니다.", category: "Technology/Docker", tags: ["docker","pros","cons","use-cases","devops"], content: ["## 장점", "- 환경 일관성, 빠른 배포, 리소스 효율, 마이크로서비스에 적합", "", "## 단점", "- 보안·격리 한계, 디버깅 복잡도, 학습 곡선", "", "## 용도", "앱 배포, 로컬 개발, CI/CD, 테스트·스테이징, 마이크로서비스", "", "---", "### 요약", "도커는 환경 일관성과 배포 효율에서 강점이 있습니다."] }
const meta_docker_desktop = { id: "docker-desktop", title: "도커 데스크톱(Docker Desktop)이란?", date: "2026-02-11", summary: "Docker Desktop은 Windows와 Mac에서 도커를 쉽게 사용할 수 있게 해주는 GUI 애플리케이션입니다.", category: "Technology/Docker", tags: ["docker","docker-desktop","gui","windows","mac","wsl2"], content: ["## 한 줄 요약", "Docker Desktop은 Windows·Mac에서 도커 엔진을 쉽게 설치·실행할 수 있게 해주는 GUI 애플리케이션입니다.", "", "## 주요 기능", "- WSL2(Hyper-V) 위에 Linux 도커 엔진 실행", "- 컨테이너·이미지·볼륨 GUI 관리", "", "---", "### 요약", "Docker Desktop은 Windows·Mac에서 도커를 쉽게 쓸 수 있게 해주는 앱입니다."] }
const meta_docker_vs_virtualization = { id: "docker-vs-virtualization", title: "도커 vs 가상화 기술(VM) 차이점", date: "2026-02-11", summary: "도커(컨테이너)와 전통적인 가상화(VM)의 차이를 정리합니다.", category: "Technology/Docker", tags: ["docker","virtualization","vm","container","comparison"], content: ["## 한눈에 비교", "| 구분 | 가상화(VM) | 도커(컨테이너) |", "|------|------------|----------------|", "| 격리 단위 | VM 전체(Guest OS 포함) | 프로세스·파일시스템·네트워크 |", "| OS | 각 VM마다 Guest OS 필요 | 호스트 커널 공유 |", "| 부팅 시간 | 수십 초~수 분 | 1초 이내 |", "", "---", "### 요약", "도커는 커널을 공유해 VM보다 가볍고 빠릅니다."] }
const meta_container_os_reality = { id: "container-os-reality", title: "컨테이너에서 돌아가는 OS의 실체", date: "2026-02-11", summary: "컨테이너 안의 Alpine/Ubuntu는 전체 OS가 아니라 rootfs입니다. 커널은 호스트와 공유합니다.", category: "Technology/Docker", tags: ["docker","container","os","rootfs","kernel"], content: ["## 핵심", "컨테이너에 있는 건 OS 전체가 아니라 rootfs(파일 트리 + 도구)입니다. 커널은 호스트와 공유하고, Alpine/Ubuntu 베이스 이미지는 그 파일 구조와 유틸리티를 제공할 뿐입니다.", "", "---", "### 요약", "컨테이너의 OS는 rootfs이며, 커널은 호스트 것을 공유합니다."] }
const meta_engine_in_software = { id: "engine-in-software", title: "엔진(Engine)이란?", date: "2026-02-11", summary: "소프트웨어에서 엔진은 특정 기능을 담당하는 핵심 컴포넌트를 말합니다.", category: "Coding/Theory", tags: ["theory","engine","architecture","basics"], content: ["## 엔진이란?", "소프트웨어에서 엔진은 특정 기능을 담당하는 핵심 컴포넌트를 말합니다.", "", "| 종류 | 예시 |", "|------|------|", "| 검색 엔진 | Elasticsearch |", "| 게임 엔진 | Unity, Unreal |", "| JS 엔진 | V8, SpiderMonkey |", "| 렌더링 엔진 | Blink, WebKit |", "", "---", "### 요약", "엔진은 특정 기능의 핵심 구현체입니다."] }
const meta_server_overview = { id: "server-overview", title: "서버(Server)란?", date: "2026-02-11", summary: "서버는 클라이언트의 요청에 응답하는 프로그램 또는 컴퓨터입니다.", category: "Coding/Theory", tags: ["theory","server","architecture","backend"], content: ["## 서버란?", "서버는 클라이언트의 요청을 받아 응답을 제공하는 프로그램, 또는 그 프로그램이 실행되는 컴퓨터를 말합니다.", "", "## 대표 서버 종류", "| 종류 | 역할 | 예시 |", "|------|------|------|", "| 웹 서버 | HTTP 요청, 정적 파일 제공 | Nginx, Apache, Caddy |", "| 애플리케이션 서버 | 동적 로직, DB 연동 | Tomcat, Node.js, Spring Boot |", "| DB 서버 | 데이터 저장·조회 | MySQL, PostgreSQL, MongoDB |", "| 메일 서버 | 이메일 발송·수신 | Postfix, SendGrid |", "| 파일 서버 | 파일 공유·저장 | NAS, FTP, S3 |", "| DNS 서버 | 도메인 → IP 변환 | Google DNS, BIND |", "| 프록시 서버 | 요청 대신 전달, 캐싱 | Nginx, Squid, Cloudflare |", "| DHCP 서버 | IP 자동 할당 | 라우터 내장, dnsmasq |", "| 인증 서버 | 로그인, 토큰 발급 | LDAP, Keycloak, Auth0 |", "", "---", "### 요약", "서버는 클라이언트 요청에 응답하는 프로그램/장비입니다. 웹·앱·DB·메일·파일·DNS·프록시·DHCP·인증 서버 등 다양한 종류가 있습니다."] }
const meta_python_print = { id: "python-print", title: "print", date: "2026-02-11", summary: "Python의 print() 함수는 값을 화면에 출력하는 가장 기본적인 방법입니다.", category: "Coding/Python", tags: ["python","print","basics","output"], content: ["## print()란?", "print()는 Python에서 값을 표준 출력(화면)에 출력하는 내장 함수입니다.", "", "## 1) 하나만 출력", "```python", "print(\"hello world!\")", "print(42)", "print(3.14)", "```", "", "## 2) 여러 개 출력 (쉼표로 구분)", "여러 값을 쉼표로 나열하면 공백으로 구분되어 한 줄에 출력됩니다.", "", "```python", "print(10, 20, 30, 40, 50)", "```", "", "## 3) sep(구분자)와 end(끝 문자)", "- sep: 값들 사이에 들어갈 문자 (기본값: 공백)", "- end: 출력 끝에 붙을 문자 (기본값: 줄바꿈)", "", "```python", "print(1, 2, 3, sep=\"-\")   # 1-2-3", "print(\"A\", end=\"\")", "print(\"B\", end=\"\")", "print(\"C\")              # ABC", "```", "", "## 4) f-string 포맷팅 (Python 3.6+)", "```python", "name = \"김철수\"", "age = 25", "print(f\"이름: {name}, 나이: {age}\")", "print(f\"원의 넓이: {3.14 * 5 ** 2:.2f}\")", "```", "", "## 5) format() 메서드", "```python", "print(\"{}의 나이는 {}살입니다.\".format(\"홍길동\", 25))", "```", "", "## 6) 이스케이프 문자", "```python", "print(\"줄바꿈\\n두 번째 줄\")", "print(\"탭\\t사이\")", "print(\"따옴표: \\\"문자\\\"\")", "```", "", "---", "### 요약", "print()는 Python에서 화면에 값을 출력하는 기본 함수입니다. sep, end, f-string, format() 등으로 다양한 출력이 가능합니다."] }
const meta_abstract_factory_pattern = { id: "abstract-factory-pattern", title: "Abstract Factory(추상 팩토리) 패턴 [생성]", date: "2026-02-11", summary: "관련된 여러 객체(제품군)를 한 묶음으로 생성하는 패턴. 제품군 단위로 구현을 교체할 수 있습니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Abstract Factory(추상 팩토리) 패턴이란?", "관련된 여러 객체(제품군)를 한 묶음으로 생성하는 패턴. 제품군 단위로 구현을 교체할 수 있습니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "관련된 여러 객체(제품군)를 한 묶음으로 생성하는 패턴. 제품군 단위로 구현을 교체할 수 있습니다."] }
const meta_builder_pattern = { id: "builder-pattern", title: "Builder(빌더) 패턴 [생성]", date: "2026-02-11", summary: "복잡한 객체를 단계적으로 생성하는 패턴. 가독성과 불변성을 높입니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Builder(빌더) 패턴이란?", "복잡한 객체를 단계적으로 생성하는 패턴. 가독성과 불변성을 높입니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "복잡한 객체를 단계적으로 생성하는 패턴. 가독성과 불변성을 높입니다."] }
const meta_singleton_pattern = { id: "singleton-pattern", title: "Singleton(싱글톤) 패턴 [생성]", date: "2026-02-11", summary: "인스턴스가 하나만 존재하도록 보장하는 패턴. 전역 공유 자원에 사용되지만, 테스트/멀티스레드에서 주의가 필요합니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Singleton(싱글톤) 패턴이란?", "인스턴스가 하나만 존재하도록 보장하는 패턴. 전역 공유 자원에 사용되지만, 테스트/멀티스레드에서 주의가 필요합니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "인스턴스가 하나만 존재하도록 보장하는 패턴. 전역 공유 자원에 사용되지만, 테스트/멀티스레드에서 주의가 필요합니다."] }
const meta_adapter_pattern = { id: "adapter-pattern", title: "Adapter(어댑터) 패턴 [구조]", date: "2026-02-11", summary: "인터페이스가 다른 객체를 우리가 기대하는 형태로 감싸는 패턴. 레거시·외부 라이브러리 연결에 유용합니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Adapter(어댑터) 패턴이란?", "인터페이스가 다른 객체를 우리가 기대하는 형태로 감싸는 패턴. 레거시·외부 라이브러리 연결에 유용합니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "인터페이스가 다른 객체를 우리가 기대하는 형태로 감싸는 패턴. 레거시·외부 라이브러리 연결에 유용합니다."] }
const meta_decorator_pattern = { id: "decorator-pattern", title: "Decorator(데코레이터) 패턴 [구조]", date: "2026-02-11", summary: "객체를 감싸서 기능을 동적으로 추가하는 패턴. 로그, 인증, 캐싱 등을 조합할 때 유용합니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Decorator(데코레이터) 패턴이란?", "객체를 감싸서 기능을 동적으로 추가하는 패턴. 로그, 인증, 캐싱 등을 조합할 때 유용합니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "객체를 감싸서 기능을 동적으로 추가하는 패턴. 로그, 인증, 캐싱 등을 조합할 때 유용합니다."] }
const meta_facade_pattern = { id: "facade-pattern", title: "Facade(퍼사드) 패턴 [구조]", date: "2026-02-11", summary: "복잡한 하위 시스템을 단순한 창구로 감싸는 패턴. 클라이언트가 여러 모듈을 한 번에 호출할 수 있게 합니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Facade(퍼사드) 패턴이란?", "복잡한 하위 시스템을 단순한 창구로 감싸는 패턴. 클라이언트가 여러 모듈을 한 번에 호출할 수 있게 합니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "복잡한 하위 시스템을 단순한 창구로 감싸는 패턴. 클라이언트가 여러 모듈을 한 번에 호출할 수 있게 합니다."] }
const meta_proxy_pattern = { id: "proxy-pattern", title: "Proxy(프록시) 패턴 [구조]", date: "2026-02-11", summary: "실제 객체 접근을 제어하는 대리 객체. 지연 로딩, 캐싱, 권한 체크에 사용됩니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Proxy(프록시) 패턴이란?", "실제 객체 접근을 제어하는 대리 객체. 지연 로딩, 캐싱, 권한 체크에 사용됩니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "실제 객체 접근을 제어하는 대리 객체. 지연 로딩, 캐싱, 권한 체크에 사용됩니다."] }
const meta_strategy_pattern = { id: "strategy-pattern", title: "Strategy(전략) 패턴 [행위]", date: "2026-02-11", summary: "알고리즘을 교체 가능하게 만드는 패턴. 결제 방식, 정렬 방식 등에 사용됩니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Strategy(전략) 패턴이란?", "알고리즘을 교체 가능하게 만드는 패턴. 결제 방식, 정렬 방식 등에 사용됩니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "알고리즘을 교체 가능하게 만드는 패턴. 결제 방식, 정렬 방식 등에 사용됩니다."] }
const meta_observer_pattern = { id: "observer-pattern", title: "Observer(관찰자) 패턴 [행위]", date: "2026-02-11", summary: "상태 변화를 구독자에게 알리는 패턴. 이벤트/구독 모델의 기반입니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Observer(관찰자) 패턴이란?", "상태 변화를 구독자에게 알리는 패턴. 이벤트/구독 모델의 기반입니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "상태 변화를 구독자에게 알리는 패턴. 이벤트/구독 모델의 기반입니다."] }
const meta_command_pattern = { id: "command-pattern", title: "Command(명령) 패턴 [행위]", date: "2026-02-11", summary: "요청을 객체로 캡슐화하는 패턴. 실행/취소/재시도, 큐에 넣기 등에 사용됩니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## Command(명령) 패턴이란?", "요청을 객체로 캡슐화하는 패턴. 실행/취소/재시도, 큐에 넣기 등에 사용됩니다.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "요청을 객체로 캡슐화하는 패턴. 실행/취소/재시도, 큐에 넣기 등에 사용됩니다."] }
const meta_state_pattern = { id: "state-pattern", title: "State(상태) 패턴 [행위]", date: "2026-02-11", summary: "상태에 따라 동작이 달라질 때 조건문 대신 상태 객체로 분리하는 패턴.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","oop"], content: ["## State(상태) 패턴이란?", "상태에 따라 동작이 달라질 때 조건문 대신 상태 객체로 분리하는 패턴.", "", "## 핵심", "design-patterns-overview에서 자세한 맥락을 확인할 수 있습니다.", "", "---", "### 요약", "상태에 따라 동작이 달라질 때 조건문 대신 상태 객체로 분리하는 패턴."] }
const meta_hello_pages = { id: "hello-pages", title: "블로그 소개", date: "2026-02-11", summary: "공부 기록을 차곡차곡 모으는 블로그입니다.", category: "Daily Life/ETC", tags: ["blog"], content: ["## 안녕하세요.", "haru1813 개발 블로그에 오신 것을 환영합니다.", "", "공부한 내용을 정리해 기록합니다."] }
const meta_ai_era_developer_growth = { id: "ai-era-developer-growth", title: "AI가 발전하는 시대, 개발자는 무엇을 자기개발해야 할까", date: "2026-02-10", summary: "코드를 ‘더 빨리’ 쓰는 것보다, 문제를 정의하고 해결하는 능력을 키우는 쪽으로 자기개발의 무게중심이 이동합니다.", category: "Coding/Theory", tags: ["theory","career","problem-solving"], content: ["## 들어가며", "AI가 점점 더 많은 코드를 대신 작성해주는 시대가 오고 있습니다. 이럴수록 개발자의 가치는 “타이핑 속도”가 아니라 문제를 제대로 정의하고, 올바른 해결책을 끝까지 완성하는 능력에서 나옵니다.", "", "## 결론부터", "- AI가 잘하는 것: 빠른 초안 생성, 코드 변환, 반복 작업 자동화", "- 개발자가 계속 잘해야 하는 것: 문제 정의, 우선순위, 품질 기준, 트레이드오프 판단, 검증과 운영", "", "## 문제의 정의 및 해결 5단계", "아래 5가지는 훈련으로 좋아집니다. 중요한 건 “머릿속”이 아니라 글로 남기는 습관이에요.", "", "### 1) 나의 자원과 상황을 파악하는 연습부터 한다", "- 지금 내가 가진 자원(시간/체력/돈/환경/도구/지식/협업 가능 여부)은 무엇인가?", "- 이번 문제에서 가장 큰 제약은 무엇인가? (마감, 성능, 품질, 보안, 유지보수, 학습 목적 등)", "- 오늘 가능한 최선은 무엇인가? (완벽 대신 “현실적 최적”)", "", "### 2) 목표를 “완료 여부가 명확하게” 정의하는 연습", "- 목표는 ‘성공/실패’를 분명히 판정할 수 있어야 합니다.", "- 나쁜 예: “성능 개선하기”, “좀 더 예쁘게 만들기”", "- 좋은 예: “LCP 2.5초 이하”, “배포 후 404 0건”, “로그인 성공률 99.9% 이상”", "", "### 3) 목표를 세부 단계로 쪼개는 훈련", "- 큰 목표를 작은 작업 단위로 나눕니다.", "- 각 단계는 ‘다음 행동’을 바로 할 수 있을 정도로 구체적이어야 합니다.", "- 예: 요구사항 정리 → 데이터/화면 설계 → 구현 → 테스트 → 배포 → 모니터링", "", "### 4) 발생할 문제를 미리 예측하는 연습", "- 실패 시나리오를 먼저 써봅니다.", "- 예: “권한이 꼬이면?”, “데이터가 비정상 값이면?”, “트래픽이 늘면?”, “배포 중 장애가 나면?”", "- 그리고 각각에 대해 최소한의 방어막(검증, 롤백, 로그, 알림)을 준비합니다.", "", "### 5) “그럼 어떻게 할지”를 글로 적는 연습", "- 마지막으로 실행 계획을 짧은 문장으로 씁니다.", "- 형식 예:", "- 오늘 할 일: …", "- 완료 조건: …", "- 리스크/대응: …", "- 다음 행동(바로 지금): …", "", "## 그럼 어떤 공부를 해야 할까", "AI가 코드를 도와줄수록, 아래 능력들이 더 중요해집니다.", "", "### (1) CS 기초(특히 ‘왜’에 대한 설명력)", "- 자료구조/알고리즘: 성능·복잡도를 말로 설명할 수 있어야 함", "- 네트워크/HTTP: 장애/지연의 원인을 추적할 수 있어야 함", "- 운영체제/동시성: 병목과 락/스레드 문제를 이해", "- DB/트랜잭션: 정합성/격리수준/인덱스 설계 감각", "", "### (2) 테스트/디버깅/관찰 가능성(Observability)", "- 단위/통합 테스트로 ‘의도’를 고정하는 능력", "- 로그/메트릭/트레이싱으로 ‘현실’을 보는 능력", "- 재현 가능한 버그 리포트 작성 능력(원인 추정 포함)", "", "### (3) 설계와 트레이드오프", "- 요구사항을 ‘기능/비기능’으로 분리해서 설계", "- 확장성 vs 단순함, 속도 vs 비용, 보안 vs 편의 같은 선택의 근거를 남기기", "", "### (4) 글쓰기(문서화)와 커뮤니케이션", "- 문제 정의/해결 과정을 문서로 남기면, 성장 속도가 빨라집니다.", "- AI에게도 “좋은 질문(맥락/제약/목표/예시)”을 주는 능력이 됩니다.", "", "---", "### 요약", "AI 시대의 자기개발은 ‘코딩 스킬’만이 아니라 문제 해결의 전 과정을 다루는 방향으로 가야 합니다.", "특히 위의 5단계를 ‘글로 쓰는 습관’으로 만들면, 실력이 빠르게 쌓입니다."] }
const meta_programming_language_types = { id: "programming-language-types", title: "프로그래밍 언어의 종류(분류 방법 정리)", date: "2026-02-10", summary: "프로그래밍 언어는 ‘이름’이 아니라 분류 축(패러다임/추상화 수준/실행 방식/타입 시스템 등)으로 이해하면 빠르게 정리됩니다.", category: "Coding/Theory", tags: ["theory","language","basics"], content: ["## 왜 ‘종류’가 헷갈릴까", "언어는 한 가지로만 분류되지 않습니다. 예를 들어 JavaScript는 인터프리터 기반 + JIT + 동적 타입 + 함수형/객체지향 혼합처럼 여러 성격을 동시에 가질 수 있어요.", "", "그래서 언어를 외우기보다, 아래 ‘분류 축’을 알면 정리가 됩니다.", "", "## 1) 추상화 수준(레벨)", "- 저수준 언어: 하드웨어에 가깝고 제어가 세밀함 (예: C, 어셈블리)", "- 고수준 언어: 사람이 읽기 쉽고 생산성이 높음 (예: Python, Java, JavaScript)", "", "핵심은 “좋다/나쁘다”가 아니라 목표(성능/안전/생산성/이식성)에 따라 선택한다는 점입니다.", "", "## 2) 패러다임(프로그래밍 스타일)", "### (1) 절차적(Procedural)", "- 순서대로 명령을 실행하며 프로그램을 구성", "- 예: C", "", "### (2) 객체지향(OOP)", "- 데이터와 동작을 객체로 묶어 모델링", "- 예: Java, C#, (Python도 가능)", "", "### (3) 함수형(Functional)", "- 함수를 값처럼 다루고, 불변/순수함수에 친화적", "- 예: Haskell, (JavaScript/Scala도 일부 지원)", "", "### (4) 선언형(Declarative)", "- “어떻게”보다 “무엇을”을 표현", "- 예: SQL, HTML/CSS(프로그래밍 언어로 볼지 논쟁은 있지만 ‘선언형’의 대표 예시)", "", "대부분의 현대 언어는 멀티 패러다임입니다.", "", "## 3) 실행 방식(컴파일/인터프리트/JIT)", "- 컴파일 언어: 실행 전 기계어/바이트코드로 변환 (예: C/C++ → 기계어, Go/Rust 등)", "- 인터프리트 언어: 실행 중에 해석하며 동작 (예: Python(전통적 설명), Ruby 등)", "- JIT(Just-In-Time): 실행 중 자주 쓰는 부분을 최적화해 빠르게 실행 (예: Java JVM, JavaScript 엔진)", "", "요즘은 경계가 섞여서 “컴파일 vs 인터프리트”만으로 단정하기 어렵고, 런타임/VM을 함께 봐야 합니다.", "", "## 4) 타입 시스템(정적/동적, 강/약)", "- 정적 타입(Static): 컴파일 단계에서 타입 오류를 더 많이 잡음 (예: Java, C#, TypeScript)", "- 동적 타입(Dynamic): 실행 중 타입이 결정 (예: Python, JavaScript)", "", "또한 강/약 타입은 언어마다 정의가 애매할 수 있어, 실무에서는 보통", "- “자동 변환이 얼마나 일어나는가”", "- “런타임 타입 오류가 얼마나 빨리 드러나는가”", "정도로 경험적으로 이해하는 편이 좋습니다.", "", "## 5) 메모리 관리(수동/자동)", "- 수동 관리: 개발자가 직접 해제까지 책임 (예: C)", "- 자동 관리(GC): 가비지 컬렉터가 메모리를 정리 (예: Java, C#, Go(형태는 다름), JavaScript)", "", "GC는 편의성을 높이지만, 성능/지연(멈춤) 특성을 이해하고 써야 합니다.", "", "## 정리: 언어를 고르는 질문", "- 내가 해결하려는 문제는 무엇인가?", "- 성능/안전/생산성 중 무엇이 중요한가?", "- 팀/생태계(라이브러리, 배포, 운영)는 준비되어 있는가?", "", "---", "### 요약", "프로그래밍 언어의 ‘종류’는 하나의 표로 끝나지 않습니다.", "대신 분류 축(레벨/패러다임/실행 방식/타입/메모리 관리)을 기준으로 보면 어떤 언어도 빠르게 이해할 수 있습니다."] }
const meta_orm_object_relational_mapping = { id: "orm-object-relational-mapping", title: "ORM(Object-Relational Mapping) 정리", date: "2026-02-10", summary: "ORM은 객체(코드)와 관계형 DB(테이블) 사이를 매핑해 SQL을 ‘직접 다루는 부담’을 줄여주는 도구입니다. 편해지는 만큼, 성능/쿼리/트랜잭션 감각은 꼭 같이 가져가야 합니다.", category: "Coding/Theory", tags: ["theory","db","orm","backend"], content: ["## ORM이란?", "ORM(Object-Relational Mapping)은 프로그램의 객체(클래스/인스턴스)를 DB의 테이블/행과 연결(매핑)해서, 데이터를 객체처럼 다룰 수 있게 해주는 기술/라이브러리입니다.", "", "쉽게 말하면:", "- DB에는 `users` 테이블이 있고", "- 코드에는 `User` 클래스가 있을 때", "- ORM이 둘 사이를 연결해 `User`를 저장/조회할 수 있게 해줍니다.", "", "## 왜 ORM을 쓸까", "- 생산성: CRUD를 빠르게 만들 수 있음", "- 유지보수: SQL 문자열을 여기저기 흩뿌리지 않게 됨", "- 안전성: 파라미터 바인딩/쿼리 빌더로 인젝션 위험을 줄임(그래도 설계가 중요)", "- 이식성(일부): DB가 바뀌어도 코드 변경을 줄일 수 있음(완전한 이식성은 기대하면 안 됨)", "", "## ORM이 해주는 것(대표 기능)", "- 매핑: 클래스 필드 ↔ 테이블 컬럼", "- 쿼리 생성: 조건/정렬/페이징 등", "- 변경 감지(Dirty Checking): 객체 수정 사항을 추적해 UPDATE를 생성", "- 관계 매핑: 1:N, N:1, N:M 등", "- 트랜잭션 단위 작업: 같은 트랜잭션에서 일관되게 처리하도록 도움", "", "## 대표 ORM 라이브러리/프레임워크(언어별)", "ORM은 언어/생태계마다 스타일이 달라요. 아래는 많이 쓰이는 선택지들입니다.", "", "### Java/Kotlin", "- JPA: 자바 ORM 표준(스펙) 자체 (구현체가 필요)", "- Hibernate: 가장 널리 쓰이는 JPA 구현체", "- Spring Data JPA: 리포지토리/쿼리 메서드 등으로 JPA 사용을 더 편하게", "", "### Python", "- Django ORM: Django에 포함된 ORM(Active Record 스타일)", "- SQLAlchemy: 파이썬에서 매우 널리 쓰이는 ORM/쿼리 빌더(강력한 표현력)", "- Peewee: 가볍고 단순한 ORM", "", "### JavaScript/TypeScript(Node.js)", "- Prisma: 스키마 기반 + 타입 생성 + 마이그레이션 경험이 좋은 편", "- TypeORM: 데코레이터 기반 ORM(프로젝트/버전에 따라 선호가 갈림)", "- Sequelize: 오래된 생태계, 다양한 DB 지원", "- MikroORM: Unit of Work/Identity Map 등 DDD 친화적 기능 강조", "", "### .NET(C#)", "- Entity Framework Core(EF Core): 대표적인 ORM", "- Dapper: 흔히 “마이크로 ORM”으로 불리며, SQL을 직접 쓰되 매핑을 편하게", "", "### Ruby", "- ActiveRecord(Rails): Rails의 기본 ORM", "", "### PHP", "- Eloquent(Laravel): Laravel의 기본 ORM", "- Doctrine ORM: PHP에서 널리 쓰이는 Data Mapper 스타일 ORM", "", "### Go", "- GORM: 가장 유명한 ORM 중 하나", "- 참고: `sqlc`는 ORM이라기보다 SQL을 기반으로 타입 안전한 코드를 생성하는 도구", "", "## ORM이 아닌데 함께 자주 언급되는 것", "- MyBatis(Java): ORM이라기보다 SQL Mapper에 가깝습니다. SQL을 직접 작성하고 매핑만 도와줍니다.", "", "## ORM을 쓸 때 꼭 알아야 하는 함정", "### 1) N+1 문제", "- 관계를 가진 데이터를 조회할 때, 예상보다 쿼리가 N번 추가로 나가는 문제", "- 해결 방향: 조인/페치 조인, eager/lazy 전략 이해, 쿼리 확인", "", "### 2) Lazy Loading(지연 로딩)과 트랜잭션 범위", "- 관계 데이터가 “필요할 때” 로딩되는데, 트랜잭션이 끝난 뒤 접근하면 오류가 날 수 있음", "- 해결 방향: 조회 시점 설계(필요한 데이터는 미리 로딩), 계층 분리 규칙 만들기", "", "### 3) ORM을 써도 SQL을 모르면 결국 막힌다", "- 인덱스, 조인, 실행 계획, 페이징 방식 같은 DB 기본기는 여전히 중요", "", "## 실무에서의 좋은 습관", "- 항상 쿼리를 확인: “내가 생각한 쿼리”가 실제로 나가는지 로그로 보기", "- 성능 기준을 정하기: 느려지는 지점은 대부분 ‘조회’에서 터짐", "- 도메인 모델과 조회 모델 분리도 고려: 복잡한 조회는 DTO/전용 쿼리로", "- 트랜잭션 경계를 명확히: 어디서 시작/끝나는지", "", "---", "### 요약", "ORM은 개발을 빠르게 해주지만, 그만큼 ‘쿼리가 보이지 않아서’ 성능 문제가 생기기 쉽습니다.", "따라서 ORM을 쓰더라도 SQL/인덱스/트랜잭션/조회 최적화 감각은 같이 키우는 게 중요합니다."] }
const meta_springboot_rest_api = { id: "springboot-rest-api", title: "Spring Boot REST API 설계와 예제", date: "2026-02-11", summary: "RESTful API 설계 원칙, Spring Web MVC 컨트롤러, Bean Validation, Global 예외 처리까지 실전 예제로 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","rest","api","validation","backend"], content: ["Spring Boot REST API 설계와 예제 글입니다."] }
const meta_springboot_security_jwt = { id: "springboot-security-jwt", title: "Spring Security + JWT 인증 구현", date: "2026-02-11", summary: "Spring Security 6.x와 JWT(JSON Web Token)를 사용한 Stateless 인증 방식을 구현하는 방법과 예제 코드를 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","security","jwt","authentication","backend"], content: ["Spring Security + JWT 인증 구현 글입니다."] }
const meta_springboot_webflux = { id: "springboot-webflux", title: "Spring WebFlux와 리액티브 프로그래밍", date: "2026-02-11", summary: "Spring WebFlux, Project Reactor, Mono/Flux 기초부터 리액티브 REST API 구현까지. 블로킹 vs 논블로킹, 언제 WebFlux를 쓰는지 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","webflux","reactive","reactor","backend"], content: ["Spring WebFlux와 리액티브 프로그래밍 글입니다."] }
const meta_springboot_actuator = { id: "springboot-actuator", title: "Spring Boot Actuator와 모니터링", date: "2026-02-11", summary: "Actuator 엔드포인트, 헬스체크, 메트릭, 커스텀 엔드포인트, 보안 설정까지 운영 환경에 필요한 모니터링 요소를 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","actuator","monitoring","health","metrics"], content: ["Spring Boot Actuator와 모니터링 글입니다."] }
const meta_springboot_docker = { id: "springboot-docker", title: "Spring Boot 애플리케이션 Docker 컨테이너화", date: "2026-02-11", summary: "Spring Boot 3.x와 Java 21 기반 Docker 이미지 빌드, 멀티 스테이지 빌드, Jib, 최적화 팁까지 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","docker","container","devops","kubernetes"], content: ["Spring Boot Docker 컨테이너화 글입니다."] }
const meta_springboot_configuration = { id: "springboot-configuration", title: "Spring Boot 설정(Configuration) 완전 정리", date: "2026-02-11", summary: "application.yml, 프로파일, @ConfigurationProperties, 외부 설정, 환경 변수, 우선순위까지 Spring Boot 설정의 모든 것을 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","configuration","yaml","profile","backend"], content: ["Spring Boot 설정 완전 정리 글입니다."] }
const meta_springboot_test = { id: "springboot-test", title: "Spring Boot 테스트 전략과 예제", date: "2026-02-11", summary: "JUnit 5, MockMvc, @DataJpaTest, @WebFluxTest, @MockBean, 통합 테스트, 컨테이너 테스트까지 Spring Boot 테스트의 모든 것을 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","test","junit","mockmvc","backend"], content: ["Spring Boot 테스트 전략과 예제 글입니다."] }
const meta_springboot_annotations = { id: "springboot-annotations", title: "Spring Boot 핵심 어노테이션 정리", date: "2026-02-11", summary: "Spring Boot에서 자주 사용하는 어노테이션을 카테고리별로 정리합니다. @SpringBootApplication, @Component, @RestController, @Transactional, @Valid 등 실전 예제와 함께 설명합니다.", category: "Technology/SpringBoot", tags: ["springboot","annotation","java","backend"], content: ["Spring Boot 핵심 어노테이션 정리 글입니다."] }
const meta_springboot_request_response = { id: "springboot-request-response", title: "Spring Boot 요청·응답 데이터 주고받기 완전 정리", date: "2026-02-11", summary: "HttpServletRequest, ResponseEntity, HttpEntity, Model, MultipartFile, 스트리밍, SSE 등 Spring Boot(Spring MVC)에서 요청 데이터를 받고 응답을 만드는 다양한 방식을 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","http","request","response","backend"], content: ["Spring Boot 요청·응답 데이터 주고받기 완전 정리 글입니다."] }
const meta_thymeleaf_overview = { id: "thymeleaf-overview", title: "Thymeleaf 템플릿 엔진 완전 정리", date: "2026-02-11", summary: "Thymeleaf는 Spring Boot에서 가장 많이 쓰이는 서버 사이드 HTML 템플릿 엔진입니다. th:text, th:each, 표현식, 폼 바인딩, Fragment, Spring Security 연동까지 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","thymeleaf","template","html","backend"], content: ["Thymeleaf 템플릿 엔진 완전 정리 글입니다."] }
const meta_accounting_overview = { id: "accounting-overview", title: "회계란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "회계는 '돈의 흐름을 기록하고 정리하는 것'입니다. 왜 회계가 필요한지, 일상에서 어떻게 쓰이는지 처음 배우는 사람 눈높이로 정리합니다.", category: "Domain/회계", tags: ["회계","기초","입문","domain"], content: ["회계란? 입문 글입니다."] }
const meta_financial_statements = { id: "financial-statements", title: "재무제표란? - 회계의 핵심 보고서", date: "2026-02-11", summary: "재무제표는 회사의 재정 상태를 보여주는 리포트입니다. 손익계산서, 재무상태표, 현금흐름표가 무엇인지 처음 보는 사람도 이해할 수 있게 정리합니다.", category: "Domain/회계", tags: ["회계","재무제표","기초","domain"], content: ["재무제표 입문 글입니다."] }
const meta_income_statement_vs_balance_sheet = { id: "income-statement-vs-balance-sheet", title: "손익계산서 vs 재무상태표 - 차이점 한눈에", date: "2026-02-11", summary: "손익계산서(P/L)와 재무상태표(B/S)의 차이를 스냅샷 vs 영상 비유로 쉽게 설명합니다. 기간 vs 시점, 흐름 vs 잔량을 구분하는 방법을 배웁니다.", category: "Domain/회계", tags: ["회계","손익계산서","재무상태표","기초","domain"], content: ["손익계산서 vs 재무상태표 글입니다."] }
const meta_debit_credit = { id: "debit-credit", title: "차변과 대변, 복식부기 - 회계 기록의 기본", date: "2026-02-11", summary: "차변(Debit)과 대변(Credit), 복식부기가 뭔지 처음 듣는 사람도 이해할 수 있게 설명합니다. 왜 두 군데에 쓰나요?", category: "Domain/회계", tags: ["회계","차변","대변","복식부기","기초","domain"], content: ["차변 대변 복식부기 글입니다."] }
const meta_assets_liabilities_equity = { id: "assets-liabilities-equity", title: "자산, 부채, 자본 - 회계의 3요소", date: "2026-02-11", summary: "자산·부채·자본이 뭔지, 일상 사례로 쉽게 이해합니다. 재무상태표를 읽기 위한 첫 단계입니다.", category: "Domain/회계", tags: ["회계","자산","부채","자본","기초","domain"], content: ["자산 부채 자본 글입니다."] }
const meta_financial_accounting = { id: "financial-accounting", title: "재무회계란? - 외부에 보여주는 회계", date: "2026-02-11", summary: "재무회계는 투자자·채권자·세무 당국 등 외부 이해관계자에게 회사의 재정 상태를 보고하는 회계입니다. 재무제표, 회계원칙, 공시 의무를 정리합니다.", category: "Domain/회계", tags: ["회계","재무회계","재무제표","기초","domain"], content: ["재무회계 입문 글입니다."] }
const meta_management_accounting = { id: "management-accounting", title: "관리회계란? - 경영을 위한 내부 회계", date: "2026-02-11", summary: "관리회계는 경영진·담당자가 의사결정을 내리기 위해 사용하는 내부용 회계입니다. 원가계산, 예산, 손익분기점, 부서별 실적 등 실무 활용을 정리합니다.", category: "Domain/회계", tags: ["회계","관리회계","원가","경영","domain"], content: ["관리회계 입문 글입니다."] }
const meta_balance_sheet_guide = { id: "balance-sheet-guide", title: "재무상태표 완전 가이드 - 예시로 읽는 법 익히기", date: "2026-02-11", summary: "재무상태표(B/S)의 구조, 각 항목의 의미, 예시를 통해 한 줄 한 줄 읽는 방법을 설명합니다. 자산·부채·자본 항목 해석과 주의할 점까지 정리합니다.", category: "Domain/회계", tags: ["회계","재무상태표","자산","부채","자본","domain"], content: ["재무상태표 완전 가이드 글입니다."] }
const meta_income_statement_guide = { id: "income-statement-guide", title: "손익계산서 완전 가이드 - 예시로 읽는 법 익히기", date: "2026-02-11", summary: "손익계산서(P/L)의 구조, 각 항목의 의미, 예시를 통해 한 줄 한 줄 읽는 방법을 설명합니다. 매출·비용·이익 항목 해석과 재무상태표와의 관계까지 정리합니다.", category: "Domain/회계", tags: ["회계","손익계산서","매출","비용","이익","domain"], content: ["손익계산서 완전 가이드 글입니다."] }
const meta_cash_flow_statement_guide = { id: "cash-flow-statement-guide", title: "현금흐름표 완전 가이드 - 예시로 읽는 법 익히기", date: "2026-02-11", summary: "현금흐름표(C/F)의 구조, 영업·투자·재무 활동 구분, 예시를 통해 한 줄 한 줄 읽는 방법을 설명합니다. 손익계산서·재무상태표와의 관계까지 정리합니다.", category: "Domain/회계", tags: ["회계","현금흐름표","현금흐름","영업활동","투자활동","domain"], content: ["현금흐름표 완전 가이드 글입니다."] }
const meta_statement_of_changes_in_equity_guide = { id: "statement-of-changes-in-equity-guide", title: "자본변동표 완전 가이드 - 예시로 읽는 법 익히기", date: "2026-02-11", summary: "자본변동표의 구조, 각 항목의 의미, 예시를 통해 한 줄 한 줄 읽는 방법을 설명합니다. 재무상태표·손익계산서와의 연결 관계까지 정리합니다.", category: "Domain/회계", tags: ["회계","자본변동표","자본","이익잉여금","domain"], content: ["자본변동표 완전 가이드 글입니다."] }
const meta_notes_to_financial_statements_guide = { id: "notes-to-financial-statements-guide", title: "재무제표 주석 완전 가이드 - 무엇을, 왜 읽어야 하나", date: "2026-02-11", summary: "재무제표 주석(Notes)은 본표 숫자 뒤에 숨은 정보를 설명하는 문서입니다. 어떤 항목이 포함되는지, 왜 중요한지, 어떻게 읽는지 정리합니다.", category: "Domain/회계", tags: ["회계","재무제표","주석","공시","domain"], content: ["재무제표 주석 완전 가이드 글입니다."] }
const meta_stock_overview = { id: "stock-overview", title: "주식이란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "주식은 회사의 일부를 소유하는 증권입니다. 주주, 배당, 상장이 뭔지 처음 주식을 접하는 사람 눈높이로 정리합니다.", category: "Domain/주식", tags: ["주식","기초","입문","domain"], content: ["주식 입문 글입니다."] }
const meta_stock_market_and_brokerage = { id: "stock-market-and-brokerage", title: "주식 시장과 증권사 - 어디서, 어떻게 사나요", date: "2026-02-11", summary: "코스피, 코스닥이 뭐고, 증권사는 어떤 역할을 하는지. 주식을 어디서 사고 파는지 처음 투자하는 사람을 위해 정리합니다.", category: "Domain/주식", tags: ["주식","시장","증권사","코스피","코스닥","domain"], content: ["주식 시장과 증권사 글입니다."] }
const meta_stock_price_basics = { id: "stock-price-basics", title: "주식 가격은 어떻게 정해지나 - 수요와 공급", date: "2026-02-11", summary: "주가가 오르고 내리는 이유를 수요·공급과 기본적 분석 관점에서 쉽게 설명합니다.", category: "Domain/주식", tags: ["주식","가격","수요","공급","기초","domain"], content: ["주식 가격 기초 글입니다."] }
const meta_stock_investment_terms = { id: "stock-investment-terms", title: "주식 투자 용어 정리 - 처음 보는 단어들", date: "2026-02-11", summary: "종목, 매수, 매도, 호가, 시가총액, PER, EPS 등 주식 투자에서 자주 나오는 용어를 처음 보는 사람 눈높이로 정리합니다.", category: "Domain/주식", tags: ["주식","용어","매수","매도","기초","domain"], content: ["주식 투자 용어 글입니다."] }
const meta_stock_investment_basics = { id: "stock-investment-basics", title: "주식 투자 전 알아야 할 것 - 리스크와 분산", date: "2026-02-11", summary: "주식 투자는 원금 보장이 없습니다. 리스크, 분산투자, 장기투자 등 처음 투자하는 사람이 꼭 알아야 할 기본 개념을 정리합니다.", category: "Domain/주식", tags: ["주식","투자","리스크","분산","기초","domain"], content: ["주식 투자 기초 글입니다."] }
const meta_economics_overview = { id: "economics-overview", title: "경제란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "경제는 한정된 자원을 어떻게 나눠 쓸까를 다루는 학문입니다. 희소성, 선택, 수요와 공급 같은 기본 개념을 정리합니다.", category: "Domain/경제", tags: ["경제","기초","입문","domain"], content: ["경제 입문 글입니다."] }
const meta_gdp_and_economic_growth = { id: "gdp-and-economic-growth", title: "GDP와 경제성장 - 나라 경제 크기를 어떻게 재나요", date: "2026-02-11", summary: "GDP(국내총생산)가 뭔지, 경제성장률은 어떻게 계산하는지 처음 듣는 사람도 이해할 수 있게 정리합니다.", category: "Domain/경제", tags: ["경제","GDP","경제성장","기초","domain"], content: ["GDP와 경제성장 글입니다."] }
const meta_inflation_and_prices = { id: "inflation-and-prices", title: "인플레이션과 물가 - 왜 물건값이 오르나요", date: "2026-02-11", summary: "인플레이션이 뭔지, 물가가 오르면 어떤 일이 생기는지 처음 경제를 배우는 사람 눈높이로 정리합니다.", category: "Domain/경제", tags: ["경제","인플레이션","물가","기초","domain"], content: ["인플레이션과 물가 글입니다."] }
const meta_interest_rates_and_monetary_policy = { id: "interest-rates-and-monetary-policy", title: "금리와 통화정책 - 한국은행이 뭘 하나요", date: "2026-02-11", summary: "금리가 뭔지, 한국은행이 금리를 올리거나 내리는 이유, 통화정책이 일상에 미치는 영향을 정리합니다.", category: "Domain/경제", tags: ["경제","금리","한국은행","통화정책","기초","domain"], content: ["금리와 통화정책 글입니다."] }
const meta_exchange_rate_basics = { id: "exchange-rate-basics", title: "환율이란? - 달러, 원화, 그 사이의 가치", date: "2026-02-11", summary: "환율이 뭔지, 왜 오르내리는지, 일상과 수출·수입에 미치는 영향을 처음 경제를 배우는 사람 눈높이로 정리합니다.", category: "Domain/경제", tags: ["경제","환율","달러","기초","domain"], content: ["환율 기초 글입니다."] }
const meta_economic_indicators_basics = { id: "economic-indicators-basics", title: "경제 지표 읽는 법 - 뉴스에서 자주 나오는 숫자들", date: "2026-02-11", summary: "GDP, 물가, 실업률, 소비자심리지수, 경기종합지수 등 뉴스에서 자주 나오는 경제 지표를 정리합니다.", category: "Domain/경제", tags: ["경제","지표","실업률","경기","기초","domain"], content: ["경제 지표 기초 글입니다."] }
const meta_seed_money_basics = { id: "seed-money-basics", title: "시드머니란? - 창업·사업의 첫 돈", date: "2026-02-11", summary: "시드머니는 창업이나 사업을 시작할 때 필요한 처음 자금입니다. 시리즈 A·B와의 차이, 어디서 구하는지 경제·창업을 처음 배우는 사람 눈높이로 정리합니다.", category: "Domain/경제", tags: ["경제","시드머니","창업","투자","기초","domain"], content: ["시드머니 기초 글입니다."] }
const meta_tax_overview = { id: "tax-overview", title: "세금이란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "세금은 나라가 국민으로부터 징수하는 돈입니다. 왜 내고, 어떤 종류가 있는지 처음 세금을 배우는 사람 눈높이로 정리합니다.", category: "Domain/세금", tags: ["세금","기초","입문","domain"], content: ["세금 입문 글입니다."] }
const meta_income_tax_basics = { id: "income-tax-basics", title: "소득세란? - 월급에서 빠지는 세금", date: "2026-02-11", summary: "소득세는 벌어들인 돈(소득)에 대해 내는 세금입니다. 과세표준, 누진세율, 공제가 뭔지 처음 세금을 배우는 사람 눈높이로 정리합니다.", category: "Domain/세금", tags: ["세금","소득세","기초","domain"], content: ["소득세 기초 글입니다."] }
const meta_four_big_insurance_and_tax = { id: "four-big-insurance-and-tax", title: "4대보험과 세금 - 월급에서 뭘 빼나요", date: "2026-02-11", summary: "월급에서 공제되는 4대보험(국민연금, 건강보험, 고용보험, 산재보험)과 소득세·지방소득세의 관계를 처음 세금을 배우는 사람 눈높이로 정리합니다.", category: "Domain/세금", tags: ["세금","4대보험","공제","기초","domain"], content: ["4대보험과 세금 글입니다."] }
const meta_tax_deductions_basics = { id: "tax-deductions-basics", title: "세금 공제란? - 세금을 줄이는 방법", date: "2026-02-11", summary: "소득공제, 세액공제가 뭔지, 어떤 항목들이 있는지 처음 세금을 배우는 사람 눈높이로 정리합니다.", category: "Domain/세금", tags: ["세금","공제","소득공제","세액공제","domain"], content: ["세금 공제 기초 글입니다."] }
const meta_year_end_tax_settlement_basics = { id: "year-end-tax-settlement-basics", title: "연말정산이란? - 1년치 세금 마무리", date: "2026-02-11", summary: "연말정산은 1년간 월급에서 공제된 세금을 실제 소득·공제에 맞게 다시 계산하는 절차입니다. 환급·추가 납부가 어떻게 결정되는지 정리합니다.", category: "Domain/세금", tags: ["세금","연말정산","환급","기초","domain"], content: ["연말정산 기초 글입니다."] }
const meta_vat_basics = { id: "vat-basics", title: "부가가치세(VAT)란? - 영수증 10%의 정체", date: "2026-02-11", summary: "부가가치세는 물건·서비스를 살 때 붙는 10% 세금입니다. 영수증에서 VAT가 어떻게 보이고, 왜 있는지 처음 세금을 배우는 사람 눈높이로 정리합니다.", category: "Domain/세금", tags: ["세금","부가가치세","VAT","기초","domain"], content: ["부가가치세 기초 글입니다."] }
const meta_real_estate_overview = { id: "real-estate-overview", title: "부동산이란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "부동산은 땅과 그 위의 건물을 말합니다. 매매, 전세, 월세 등 기본 거래 방식과 용어를 처음 부동산을 배우는 사람 눈높이로 정리합니다.", category: "Domain/부동산", tags: ["부동산","기초","입문","domain"], content: ["부동산 입문 글입니다."] }
const meta_real_estate_transaction_basics = { id: "real-estate-transaction-basics", title: "부동산 거래 방식 - 매매, 전세, 월세", date: "2026-02-11", summary: "매매·전세·월세의 차이, 각각의 특징과 비용을 처음 부동산을 배우는 사람 눈높이로 정리합니다.", category: "Domain/부동산", tags: ["부동산","매매","전세","월세","기초","domain"], content: ["부동산 거래 기초 글입니다."] }
const meta_apartment_terms = { id: "apartment-terms", title: "아파트·부동산 용어 정리 - 처음 보는 단어들", date: "2026-02-11", summary: "전용면적, 공급면적, 평형, 실거주면적, 관리비 등 부동산에서 자주 나오는 용어를 처음 부동산을 배우는 사람 눈높이로 정리합니다.", category: "Domain/부동산", tags: ["부동산","아파트","용어","면적","기초","domain"], content: ["아파트 용어 글입니다."] }
const meta_real_estate_loan_basics = { id: "real-estate-loan-basics", title: "주택담보대출이란? - 집 살 때 받는 대출", date: "2026-02-11", summary: "주택담보대출은 집을 담보로 받는 대출입니다. LTV, DTI, 금리 종류, 상환 방식 등 처음 부동산·대출을 배우는 사람 눈높이로 정리합니다.", category: "Domain/부동산", tags: ["부동산","대출","주담대","LTV","기초","domain"], content: ["주택담보대출 기초 글입니다."] }
const meta_jeonse_and_monthly_rent = { id: "jeonse-and-monthly-rent", title: "전세와 월세 - 어떤 게 나을까", date: "2026-02-11", summary: "전세와 월세의 차이, 보증금·월세 부담, 반전세, 전세 사기 주의사항을 처음 부동산을 배우는 사람 눈높이로 정리합니다.", category: "Domain/부동산", tags: ["부동산","전세","월세","반전세","기초","domain"], content: ["전세와 월세 글입니다."] }
const meta_real_estate_tax_basics = { id: "real-estate-tax-basics", title: "부동산 관련 세금 - 취득세, 재산세, 양도소득세", date: "2026-02-11", summary: "부동산을 사거나 보유·팔 때 내는 취득세, 재산세, 양도소득세를 처음 부동산·세금을 배우는 사람 눈높이로 정리합니다.", category: "Domain/부동산", tags: ["부동산","세금","취득세","재산세","양도소득세","domain"], content: ["부동산 세금 글입니다."] }
const meta_registry_reading_guide = { id: "registry-reading-guide", title: "등기부등본 보는 법 - 표제부·갑구·을구 용어 풀이", date: "2026-02-11", summary: "등기부등본은 부동산의 소유자, 담보, 권리 관계를 알 수 있는 공식 문서입니다. 표제부·갑구·을구 구조와 등기부에 적힌 모든 용어를 처음 부동산을 배우는 사람 눈높이로 풀이합니다.", category: "Domain/부동산", tags: ["부동산","등기부등본","표제부","갑구","을구","domain"], content: ["등기부등본 보는 법 글입니다."] }
const meta_finance_overview = { id: "finance-overview", title: "금융이란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "금융은 돈의 융통, 즉 돈을 모으고 빌리고 나누는 일입니다. 은행, 보험, 증권이 뭔지 처음 금융을 배우는 사람 눈높이로 정리합니다.", category: "Domain/금융", tags: ["금융","기초","입문","domain"], content: ["금융 입문 글입니다."] }
const meta_banks_and_financial_institutions = { id: "banks-and-financial-institutions", title: "은행과 금융기관 - 돈은 어디서 다루나요", date: "2026-02-11", summary: "은행, 증권사, 보험사, 카드사 등 금융기관이 각각 무엇을 하는지, 어떻게 다른지 처음 금융을 배우는 사람 눈높이로 정리합니다.", category: "Domain/금융", tags: ["금융","은행","금융기관","기초","domain"], content: ["은행과 금융기관 글입니다."] }
const meta_deposits_and_savings = { id: "deposits-and-savings", title: "예금과 적금 - 은행에 돈 맡기기", date: "2026-02-11", summary: "예금과 적금의 차이, 자유적금·정기적금, 금리가 뭔지 처음 금융을 배우는 사람 눈높이로 정리합니다.", category: "Domain/금융", tags: ["금융","예금","적금","은행","기초","domain"], content: ["예금과 적금 글입니다."] }
const meta_interest_basics = { id: "interest-basics", title: "이자란? - 돈을 빌리거나 맡길 때 붙는 것", date: "2026-02-11", summary: "이자는 돈을 빌리거나 맡겼을 때 붙는 대가입니다. 단리·복리, 예금금리·대출금리의 차이를 처음 금융을 배우는 사람 눈높이로 정리합니다.", category: "Domain/금융", tags: ["금융","이자","금리","기초","domain"], content: ["이자 기초 글입니다."] }
const meta_credit_and_credit_rating = { id: "credit-and-credit-rating", title: "신용이란? - 신용등급과 신용카드", date: "2026-02-11", summary: "신용은 빌린 돈을 갚을 능력과 의지입니다. 신용등급, 신용카드와 체크카드의 차이를 처음 금융을 배우는 사람 눈높이로 정리합니다.", category: "Domain/금융", tags: ["금융","신용","신용등급","신용카드","기초","domain"], content: ["신용과 신용등급 글입니다."] }
const meta_loan_basics = { id: "loan-basics", title: "대출이란? - 돈을 빌릴 때 알아야 할 것", date: "2026-02-11", summary: "대출은 금융기관에서 돈을 빌리는 것입니다. 원리금상환, 금리 종류, 신용대출과 담보대출의 차이를 처음 금융을 배우는 사람 눈높이로 정리합니다.", category: "Domain/금융", tags: ["금융","대출","이자","기초","domain"], content: ["대출 기초 글입니다."] }
const meta_securities_basics = { id: "securities-basics", title: "증권이란? - 주식·채권·펀드의 공통 이름", date: "2026-02-11", summary: "증권은 주식, 채권, 펀드 등 투자자에게 권리를 증명하는 문서·전자 기록입니다. 증권의 종류와 예금과의 차이를 처음 금융을 배우는 사람 눈높이로 정리합니다.", category: "Domain/금융", tags: ["금융","증권","주식","채권","펀드","기초","domain"], content: ["증권 기초 글입니다."] }
const meta_financial_regulators_overview = { id: "financial-regulators-overview", title: "금융 당국 구조 - 금융위원회, 금융감독원, 한국은행, 예금보험공사", date: "2026-02-11", summary: "금융 시장을 감독하고 운영하는 4대 금융 당국을 정리합니다. 금융위원회, 금융감독원, 한국은행, 예금보험공사가 각각 어떤 역할을 하는지 처음 금융을 배우는 사람 눈높이로 설명합니다.", category: "Domain/금융", tags: ["금융","금융위원회","금융감독원","한국은행","예금보험공사","domain"], content: ["금융 당국 구조 글입니다."] }
const meta_law_overview = { id: "law-overview", title: "법이란? - 아무것도 모르는 사람을 위한 첫 걸음", date: "2026-02-11", summary: "법은 사회 구성원이 지켜야 할 규칙입니다. 왜 법이 있고, 어떤 종류가 있는지 처음 법을 배우는 사람 눈높이로 정리합니다.", category: "Domain/법", tags: ["법","기초","입문","domain"], content: ["법 입문 글입니다."] }
const meta_civil_law_basics = { id: "civil-law-basics", title: "민법이란? - 사람 간 재산·의무의 법", date: "2026-02-11", summary: "민법은 사람과 사람 사이의 재산·계약·가족 관계를 다룹니다. 계약, 채권채무, 부동산, 상속 등 처음 법을 배우는 사람 눈높이로 정리합니다.", category: "Domain/법", tags: ["법","민법","계약","기초","domain"], content: ["민법 기초 글입니다."] }
const meta_criminal_law_basics = { id: "criminal-law-basics", title: "형법이란? - 범죄와 처벌의 법", date: "2026-02-11", summary: "형법은 범죄가 무엇인지, 어떤 처벌을 받는지 정한 법입니다. 죄형법정주의, 공소시효 등 처음 법을 배우는 사람 눈높이로 정리합니다.", category: "Domain/법", tags: ["법","형법","범죄","기초","domain"], content: ["형법 기초 글입니다."] }
const meta_labor_law_basics = { id: "labor-law-basics", title: "근로기준법이란? - 일할 때 알아야 할 법", date: "2026-02-11", summary: "근로기준법은 근로자의 최소한의 권리를 보장하는 법입니다. 최저임금, 근로시간, 휴가, 해고 등 처음 법을 배우는 사람 눈높이로 정리합니다.", category: "Domain/법", tags: ["법","근로기준법","노동","기초","domain"], content: ["근로기준법 기초 글입니다."] }
const meta_contract_basics = { id: "contract-basics", title: "계약이란? - 법적 구속력이 생기는 약속", date: "2026-02-11", summary: "계약은 두 사람 이상이 서로 의무를 지기로 하는 법적 합의입니다. 구두·서면, 해제·해지, 불이행 시 어떻게 되는지 처음 법을 배우는 사람 눈높이로 정리합니다.", category: "Domain/법", tags: ["법","계약","민법","기초","domain"], content: ["계약 기초 글입니다."] }
const meta_legal_system_overview = { id: "legal-system-overview", title: "법원·검찰·변호사 - 법이 돌아가는 구조", date: "2026-02-11", summary: "법원은 재판을, 검찰은 수사·기소를, 변호사는 당사자를 대신해 법적 도움을 제공합니다. 삼권분립과 재판 절차를 처음 법을 배우는 사람 눈높이로 정리합니다.", category: "Domain/법", tags: ["법","법원","검찰","변호사","기초","domain"], content: ["법원·검찰·변호사 글입니다."] }
const meta_korea_three_branches = { id: "korea-three-branches", title: "대한민국 3대 기관 - 국회, 정부, 법원", date: "2026-02-11", summary: "대한민국의 3대 기관은 국회(입법), 정부(행정), 법원(사법)입니다. 삼권분립 구조에서 각 기관이 어떤 역할을 하는지 쉽게 정리합니다.", category: "Domain/Theory", tags: ["대한민국","국회","정부","법원","삼권분립","domain"], content: ["대한민국 3대 기관 글입니다."] }
const meta_korea_adult_resident_id = { id: "korea-adult-resident-id", title: "주민등록번호와 주민등록증", date: "2026-02-11", summary: "주민등록번호는 대한민국 국민 고유의 식별 번호입니다. 구조, 주민등록증 발급·재발급, 분실 시 조치를 정리합니다.", category: "Domain/Theory", tags: ["대한민국","주민등록","신분증","상식","domain"], content: ["주민등록 상식 글입니다."] }
const meta_korea_adult_voting = { id: "korea-adult-voting", title: "선거권과 투표", date: "2026-02-11", summary: "만 18세가 되면 선거권이 생깁니다. 국회의원 선거, 대통령 선거, 지방선거 등 투표 방법과 사전투표를 정리합니다.", category: "Domain/Theory", tags: ["대한민국","선거","투표","상식","domain"], content: ["선거·투표 상식 글입니다."] }
const meta_korea_adult_government_services = { id: "korea-adult-government-services", title: "정부24와 국민신문고 - 온라인 민원·신고", date: "2026-02-11", summary: "정부24는 다양한 민원을 온라인으로 처리하는 통합 포털입니다. 국민신문고는 불편·부당한 처우를 신고하는 창구입니다. 유용한 정부 서비스를 정리합니다.", category: "Domain/Theory", tags: ["대한민국","정부24","국민신문고","민원","상식","domain"], content: ["정부 서비스 상식 글입니다."] }
const meta_korea_adult_four_basic_duties = { id: "korea-adult-four-basic-duties", title: "국민의 4대 기본 의무", date: "2026-02-11", summary: "헌법에 정해진 국민의 4대 기본 의무는 납세, 국방, 교육, 환경보전입니다. 각각 무엇을 의미하는지 정리합니다.", category: "Domain/Theory", tags: ["대한민국","4대의무","납세","국방","교육","환경보전","domain"], content: ["국민 4대 의무 상식 글입니다."] }
const meta_korea_adult_citizen_rights_duties = { id: "korea-adult-citizen-rights-duties", title: "국민의 권리", date: "2026-02-11", summary: "헌법에 정해진 국민의 기본권을 정리합니다. 참정권, 평등권, 자유권, 사회권, 청원권 등 각 권리의 의미와 내용을 자세히 설명합니다.", category: "Domain/Theory", tags: ["대한민국","권리","헌법","기본권","domain"], content: ["국민 권리 글입니다."] }
const meta_korea_adult_seal_notarization = { id: "korea-adult-seal-notarization", title: "인감과 공증 - 계약·문서할 때 알아야 할 것", date: "2026-02-11", summary: "인감은 본인임을 확인하는 도장이고, 공증은 공증인이 문서의 진위·일자를 증명하는 제도입니다. 부동산, 계약서 등에서 자주 쓰이므로 알아두면 좋습니다.", category: "Domain/Theory", tags: ["대한민국","인감","공증","계약","상식","domain"], content: ["인감·공증 상식 글입니다."] }
const meta_springboot_jpa_hibernate = { id: "springboot-jpa-hibernate", title: "📚 JPA와 하이버네이트(Spring Boot에서 이해하기)", date: "2026-02-10", summary: "JPA는 ‘표준(스펙)’, Hibernate는 ‘대표 구현체’입니다. Spring Boot에서는 이 둘이 어떻게 연결되는지, 그리고 실무에서 어디가 자주 헷갈리는지 정리합니다.", category: "Technology/SpringBoot", tags: ["springboot","jpa","hibernate","backend","db"], content: ["## 한 줄 요약", "- JPA: 자바 ORM 표준(인터페이스/규약)", "- Hibernate: JPA를 구현한 구현체(라이브러리)", "- Spring Data JPA: JPA 사용을 더 편하게 만드는 스프링 모듈", "", "## Spring Boot에서의 구조(그림 대신 문장으로)", "- 애플리케이션 코드는 JPA(표준 API)를 사용", "- 실제 동작(쿼리 생성/실행)은 Hibernate가 담당", "- Spring Boot는 설정을 자동으로 구성(데이터소스/트랜잭션/엔티티매니저 등)", "", "## 왜 ‘JPA를 쓴다’고 말하지만 Hibernate가 보일까", "JPA는 표준이라서 “JPA만 설치”해선 실제로 동작하지 않습니다. 구현체가 필요하고, Spring Boot는 기본적으로 Hibernate를 많이 사용합니다.", "", "## 핵심 개념 4가지", "### 1) 영속성 컨텍스트(Persistence Context)", "- 엔티티를 관리하는 “1차 캐시 + 변경 감지 + 동일성 보장” 공간", "- 같은 트랜잭션 안에서 같은 id를 조회하면 같은 객체처럼 다뤄짐(동일성)", "", "### 2) 변경 감지(Dirty Checking)", "- 엔티티 필드를 바꾸면, 커밋 시점에 ORM이 UPDATE를 만들어 반영", "- 그래서 ‘save를 안 했는데 업데이트가 된다’ 같은 현상이 자연스러운 동작일 수 있음", "", "### 3) 지연 로딩(Lazy Loading)과 N+1", "- 관계 엔티티를 “필요할 때” 불러오는 방식이 흔함", "- 설계를 잘못하면 N+1 문제가 발생(조회 쿼리 폭증)", "", "### 4) 트랜잭션 경계(@Transactional)", "- JPA/Hibernate는 트랜잭션 범위에 강하게 의존", "- Lazy Loading이 트랜잭션 밖에서 터지는 이유도 대부분 여기서 발생", "", "## 실무 팁(꼭 해두면 좋은 것)", "- SQL 로그를 항상 확인: 내가 의도한 쿼리가 나가는지 보기", "- 조회는 특히 조심: 성능 문제는 대개 조회에서 터짐(조인/인덱스/페이징)", "- 복잡한 조회는 엔티티가 아니라 DTO/전용 쿼리로 분리하는 것도 전략", "- “JPA를 쓴다” = “SQL을 몰라도 된다”가 절대 아님", "", "---", "### 요약", "Spring Boot에서 JPA를 사용한다는 말은 보통 Hibernate를 통해 JPA 표준을 사용한다는 뜻입니다.", "그리고 성능/버그의 대부분은 트랜잭션, 지연 로딩, 쿼리에서 생기니 여기를 중심으로 공부하면 좋습니다."] }
const meta_design_patterns_overview = { id: "design-patterns-overview", title: "디자인 패턴 정리(왜 쓰고, 어떻게 적용할까)", date: "2026-02-10", summary: "디자인 패턴은 ‘정답 템플릿’이 아니라, 반복되는 설계 문제를 더 읽기 쉽고 확장 가능하게 푸는 ‘이름 붙은 방법’입니다. 언제 쓰고 언제 피해야 하는지까지 같이 정리합니다.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","architecture","oop"], content: ["## 디자인 패턴이란?", "디자인 패턴은 소프트웨어 설계에서 자주 반복되는 문제를 해결하는 재사용 가능한 설계 아이디어입니다.", "중요한 포인트는 ‘코드 조각’이 아니라 구조와 역할이라는 점이에요.", "", "## 왜 패턴을 배울까", "- 의사소통: “여기 팩토리로 빼자”처럼 짧게 합의 가능", "- 확장성: 기능 추가 시 수정 범위를 줄이는 데 도움", "- 테스트 용이성: 의존성 분리/역전으로 테스트가 쉬워짐", "- 복잡도 관리: 커지는 코드를 ‘역할’로 나누는 기준 제공", "", "## 패턴을 쓸 때의 주의점", "- 패턴은 도구입니다. 문제보다 패턴이 먼저 나오면 과설계가 됩니다.", "- “패턴 적용” 자체가 목표가 아니라, 변경에 강한 구조가 목표입니다.", "", "## 대표 분류(GoF: 생성/구조/행위)", "### 1) 생성(Creational) 패턴", "객체를 ‘어떻게 만들지’를 다룹니다.", "- Factory Method / Abstract Factory: 생성 로직을 분리해 교체/확장을 쉽게", "- Builder: 복잡한 객체를 단계적으로 생성(옵션이 많을 때 유용)", "- Singleton: 전역 1개 인스턴스(남용하면 테스트/결합도 문제)", "", "### 2) 구조(Structural) 패턴", "객체/클래스를 ‘어떻게 조합할지’를 다룹니다.", "- Adapter: 인터페이스를 맞춰서 붙이기(레거시/외부 라이브러리 연결)", "- Decorator: 기능을 덧붙이기(상속 대신 조합)", "- Facade: 복잡한 하위 시스템을 단순한 창구로 감싸기", "- Proxy: 실제 객체 접근을 제어(캐싱, 지연 로딩, 권한 등)", "", "### 3) 행위(Behavioral) 패턴", "객체가 ‘어떻게 협력할지’를 다룹니다.", "- Strategy: 알고리즘을 교체 가능하게(결제 방식, 정렬 방식 등)", "- Observer: 이벤트/구독 모델(상태 변화 알림)", "- Command: 요청을 객체로 캡슐화(실행/취소/재시도)", "- State: 상태에 따라 동작이 크게 달라질 때 조건문을 객체로 분리", "", "## 실무에서 ‘패턴’이 자연스럽게 쓰이는 순간", "- 조건문(`if/else` 또는 `switch`)이 계속 늘어날 때 → Strategy/State 고려", "- 생성 코드가 여기저기 복제될 때 → Factory/Builder 고려", "- 외부 API/라이브러리 교체 가능성을 남기고 싶을 때 → Adapter/Facade 고려", "- 기능을 조합해서 붙이고 싶을 때(로그, 인증, 캐싱) → Decorator/Proxy 고려", "", "## 패턴 적용 체크리스트(짧게)", "- 변경이 자주 일어나는 지점인가?", "- 역할/경계가 명확해지는가?", "- 테스트가 쉬워지는가?", "- 팀이 이해/유지할 수 있는 복잡도인가?", "", "---", "### 요약", "디자인 패턴은 ‘외우는 목록’이 아니라 변경에 강한 구조를 만드는 사고 도구입니다.", "문제를 먼저 정의하고, 그 다음에 패턴을 선택하면 과설계 없이도 큰 효과를 볼 수 있습니다."] }
const meta_factory_method_pattern = { id: "factory-method-pattern", title: "Factory Method(팩토리 메서드) 패턴 [생성]", date: "2026-02-10", summary: "객체 생성 코드가 여기저기 퍼지고, 타입 분기가 늘어날 때 ‘생성 책임’을 한 곳으로 모으는 패턴이 Factory Method입니다. 생성은 서브클래스가, 사용은 상위 타입이 담당하게 만들 수 있어요.", category: "Technology/Design-Pattern", tags: ["theory","design-pattern","factory-method","java","oop"], content: ["## Factory Method란?", "Factory Method 패턴은 ‘객체를 생성하는 책임’을 별도의 메서드(팩토리 메서드)로 분리해서,", "클라이언트가 구체 클래스를 직접 `new` 하지 않도록 만드는 생성 패턴입니다.", "", "핵심은 이거예요:", "- 사용하는 쪽은 인터페이스(상위 타입)만 안다.", "- 무엇을 생성할지는 Creator(또는 그 서브클래스)가 결정한다.", "", "## 언제 필요할까", "- `if/else` 또는 `switch`로 타입을 나눠 `new` 하는 코드가 늘어난다", "- 생성 로직(기본값, 검증, 조립)이 반복된다", "- 같은 인터페이스를 구현한 다양한 구현체를 상황에 따라 바꿔 끼우고 싶다", "", "## 장점/단점(현실적으로)", "### 장점", "- 객체 생성 책임이 한 곳으로 모여 중복이 줄고, 변경에 강해짐", "- 클라이언트가 구체 타입에 덜 의존 → 테스트/확장이 쉬워짐", "", "### 단점", "- 클래스/구조가 늘어날 수 있음(작은 프로젝트에선 과할 수 있음)", "", "## Java 예제", "아래 예제는 “알림(Notification)”을 `EMAIL`/`SMS`로 생성하는 상황을 예로 듭니다.", "", "### 1) Product(인터페이스)와 ConcreteProduct", "```java", "interface Notification {", "    void send(String to, String message);", "}", "", "class EmailNotification implements Notification {", "    @Override", "    public void send(String to, String message) {", "        System.out.println(\"[EMAIL] to=\" + to + \" message=\" + message);", "    }", "}", "", "class SmsNotification implements Notification {", "    @Override", "    public void send(String to, String message) {", "        System.out.println(\"[SMS] to=\" + to + \" message=\" + message);", "    }", "}", "```", "", "### 2) Creator(팩토리 메서드 + 템플릿 메서드 느낌)", "```java", "abstract class NotificationService {", "    // Factory Method: 무엇을 만들지(구현체 선택)는 서브클래스가 결정", "    protected abstract Notification createNotification();", "", "    // 클라이언트가 호출하는 로직(공통 흐름)은 상위 클래스에 둔다", "    public void notify(String to, String message) {", "        // 공통 전처리/검증/로깅 등을 여기에 두기 좋다", "        if (to == null || to.isBlank()) throw new IllegalArgumentException(\"to is blank\");", "        if (message == null) message = \"\";", "", "        Notification notification = createNotification();", "        notification.send(to, message);", "    }", "}", "```", "", "### 3) ConcreteCreator", "```java", "class EmailNotificationService extends NotificationService {", "    @Override", "    protected Notification createNotification() {", "        return new EmailNotification();", "    }", "}", "", "class SmsNotificationService extends NotificationService {", "    @Override", "    protected Notification createNotification() {", "        return new SmsNotification();", "    }", "}", "```", "", "### 4) Client", "```java", "public class Main {", "    public static void main(String[] args) {", "        NotificationService service1 = new EmailNotificationService();", "        service1.notify(\"haru@example.com\", \"안녕하세요!\");", "", "        NotificationService service2 = new SmsNotificationService();", "        service2.notify(\"010-1234-5678\", \"문자 알림입니다.\");", "    }", "}", "```", "", "## 정리", "- Factory Method는 ‘new를 숨기는 패턴’이 아니라, 생성 책임을 분리해 변경에 강한 구조를 만드는 방법입니다.", "- 공통 흐름(검증/로깅/정책)은 상위 클래스에, 구현체 선택은 팩토리 메서드로 분리하면 깔끔해집니다."] }
const meta_ai_ml_dl_overview = { id: "ai-ml-dl-overview", title: "인공지능(AI), 약/강 인공지능, 머신러닝, 딥러닝 한 번에 정리", date: "2026-02-10", summary: "AI ⊃ 머신러닝 ⊃ 딥러닝 관계부터, 머신러닝의 지도/비지도/강화학습을 한 눈에 정리합니다.", category: "Technology/AI", tags: ["ai","machine-learning","deep-learning","basics"], content: ["## 큰 그림(포함 관계)", "- 인공지능(AI): 사람의 ‘지능적 작업’을 기계가 수행하게 하는 넓은 영역", "- 머신러닝(ML): 데이터를 통해 규칙/패턴을 ‘학습’하게 만드는 AI의 한 분야", "- 딥러닝(DL): 신경망(특히 깊은 신경망)을 이용하는 머신러닝의 한 분야", "", "즉, 보통 이렇게 이해하면 됩니다:", "- AI ⊃ ML ⊃ DL", "", "## 인공지능(AI)", "AI는 문제를 풀기 위해 꼭 ‘학습’만 쓰지 않습니다.", "- 규칙 기반(전문가 시스템)", "- 탐색/계획(게임, 경로 탐색 등)", "- 최적화(스케줄링, 배치 등)", "- 머신러닝/딥러닝", "", "## 약인공지능(ANI) vs 강인공지능(AGI)", "### 약인공지능(ANI: Artificial Narrow Intelligence)", "- 특정 과제에 특화된 AI", "- 예: 스팸 필터, 번역, 추천 시스템, 이미지 분류, 음성 인식", "- 현재 현실에서 쓰이는 AI의 대부분이 ANI입니다.", "", "### 강인공지능(AGI: Artificial General Intelligence)", "- 사람처럼 다양한 영역에서 일반적인 문제 해결이 가능한 AI", "- 현실적으로는 아직 연구/가설 단계에 가까운 개념입니다.", "", "## 머신러닝(ML)", "머신러닝은 크게 지도학습 / 비지도학습 / 강화학습으로 나눠서 생각하면 편합니다.", "", "### 1) 지도학습(Supervised Learning)", "- 정답(라벨)이 있는 데이터로 학습", "- 목표: 입력 → 정답을 잘 맞히기", "- 예:", "  - 스팸/정상 분류(분류)", "  - 집값 예측(회귀)", "", "대표 알고리즘 예:", "- 선형 회귀, 로지스틱 회귀, 결정 트리, 랜덤 포레스트, SVM, 신경망 등", "", "### 2) 비지도학습(Unsupervised Learning)", "- 정답(라벨) 없이 데이터의 구조를 찾기", "- 목표: 군집/분포/차원 구조를 발견", "- 예:", "  - 고객 세그먼트 나누기(군집화)", "  - 차원 축소로 시각화/특징 추출(PCA 등)", "", "대표 알고리즘 예:", "- K-means, DBSCAN, PCA, 오토인코더 등", "", "### 3) 강화학습(Reinforcement Learning)", "- 에이전트가 환경에서 행동하고, 보상(reward)을 최대화하도록 학습", "- 목표: 장기 보상의 최적화(탐험 vs 활용)", "- 예:", "  - 게임 플레이(알파고류)", "  - 로봇 제어, 추천/광고의 정책 최적화", "", "핵심 용어:", "- 상태(state), 행동(action), 보상(reward), 정책(policy)", "", "## 딥러닝(DL)", "딥러닝은 신경망을 깊게 쌓아(다층) 복잡한 패턴을 학습합니다.", "- 이미지/음성/자연어처럼 ‘비정형 데이터’에서 강점을 보이는 경우가 많습니다.", "", "대표 모델/구조 예:", "- CNN(이미지), RNN/LSTM(시계열/문장), Transformer(자연어/범용)", "", "## 정리(실무 관점 질문)", "- 문제에 ‘학습’이 필요한가? 아니면 규칙/검색/최적화가 더 적절한가?", "- 라벨(정답)이 있는가? → 지도학습 가능", "- 라벨이 없다면 구조를 찾는가? → 비지도학습/표현학습", "- 행동의 연쇄와 보상이 핵심인가? → 강화학습", "", "---", "### 요약", "AI는 가장 넓은 개념이고, ML은 데이터로 학습하는 AI, DL은 신경망 기반 ML입니다.", "머신러닝은 지도/비지도/강화학습으로 나눠서 이해하면 대부분의 용어가 정리됩니다."] }
const meta_prompt_engineering = { id: "prompt-engineering", title: "프롬프트 엔지니어링(Prompt Engineering) 기초 정리", date: "2026-02-10", summary: "프롬프트 엔지니어링은 ‘말을 예쁘게 쓰는 기술’이 아니라, 모델이 올바른 출력에 도달하도록 목표·맥락·제약·검증을 설계하는 작업입니다.", category: "Technology/AI", tags: ["ai","prompt","llm","basics"], content: ["## 프롬프트 엔지니어링이란?", "LLM(대규모 언어 모델)에게 원하는 결과를 얻기 위해 질문(프롬프트)을 구조화하고,", "맥락/제약/출력 형식/평가 기준을 명확히 설계하는 방법입니다.", "", "## 왜 중요한가", "- 같은 모델이라도 프롬프트에 따라 결과 품질이 크게 달라집니다.", "- ‘정답’이 아니라도, 일관성/재현성이 필요합니다.", "- 특히 실무에서는 “좋은 답”보다 안전하고 예측 가능한 답이 중요할 때가 많습니다.", "", "## 좋은 프롬프트의 기본 구성(템플릿)", "- 역할(Role): 너는 무엇을 하는가?", "- 목표(Goal): 무엇을 만들어야 하는가?", "- 맥락(Context): 필요한 배경 정보/데이터는 무엇인가?", "- 제약(Constraints): 금지/허용, 길이, 톤, 도구 사용, 언어 등", "- 출력 형식(Output format): JSON, 표, 불릿, 단계 등", "- 평가 기준(Eval): 무엇이 ‘좋은 결과’인지", "", "## 예시(간단 템플릿)", "```", "[역할] 너는 시니어 백엔드 개발자다.", "[목표] 아래 요구사항으로 API 설계안을 작성해라.", "[맥락] 서비스는 ... DB는 ... 트래픽은 ...", "[제약] 응답은 마크다운, 섹션은 Summary/Endpoints/Errors로 제한.", "[형식] 각 엔드포인트는 method/path/request/response 예시 포함.", "```", "", "## 자주 쓰는 기법들", "### 1) 예시 제공(Few-shot)", "- 원하는 출력 예시를 1~3개 보여주면 스타일/형식이 안정됩니다.", "", "### 2) 단계적 접근(체인처럼 쪼개기)", "- 한 번에 큰 일을 시키기보다,", "  - 요구사항 정리 → 설계 → 구현 → 테스트", "  같은 식으로 단계 분리하면 품질이 좋아집니다.", "", "### 3) 명확한 포맷 고정", "- JSON 스키마/마크다운 템플릿 등을 강하게 고정하면 후처리가 쉬워집니다.", "", "### 4) 금지 조건/안전 조건", "- 예: “추측하지 말고 모르면 모른다고 말하기”, “개인정보/비밀키는 출력하지 않기” 등", "", "## 흔한 실패 원인", "- 목표가 모호함(‘좋게’, ‘예쁘게’, ‘최적화’ 같은 표현만 있음)", "- 입력 데이터가 부족함(예시/제약/환경 정보가 없음)", "- 검증 기준이 없음(정답 판정이 불가)", "- 한 프롬프트에 너무 많은 일을 시킴", "", "## 실무에서의 추천 흐름", "1. 문제 정의: 무엇을 자동화/보조하려는가", "2. 입력/출력 정의: 어떤 데이터가 들어오고 무엇을 내보내야 하는가", "3. 제약 설정: 금지/허용/톤/길이/형식", "4. 평가: 좋은 결과/나쁜 결과 예시 만들기", "5. 반복 개선: 실패 케이스를 모아 프롬프트/가드레일 강화", "", "## 실무 예시: ChatGPT를 이렇게 활용한다", "아래 예시는 ‘그대로 복사해서’ 써도 되는 템플릿입니다. 중요한 건 “무엇을 원한다(완료 조건)”와 “입력(맥락)”을 같이 주는 거예요.", "", "### 1) 버그 원인 후보 좁히기(재현 정보 기반)", "```", "[역할] 너는 시니어 백엔드 개발자다.", "[목표] 아래 현상의 가능한 원인 Top 5를 우선순위로 정리하고, 각 원인을 검증하는 체크리스트를 제시해줘.", "[맥락] 환경: OS/런타임/버전… / 증상: … / 로그: … / 최근 변경: …", "[제약] 추측은 하되, 근거(왜 그런지)를 반드시 적어줘. 모르면 모른다고 말해줘.", "```", "", "### 2) 코드 리뷰 요청(안전/성능/가독성 관점)", "```", "[역할] 너는 코드리뷰어다.", "[목표] 아래 코드를 리뷰해서 (1) 버그 가능성 (2) 성능 병목 (3) 보안/예외 처리 (4) 리팩토링 제안을 각각 bullet로 작성해줘.", "[맥락] 이 코드는 ...에서 쓰이고, 트래픽은 ... 정도야.", "[제약] ‘왜’가 없는 지적은 하지 말고, 근거와 개선안을 같이 써줘.", "[입력] (코드 붙여넣기)", "```", "", "### 3) 문서/요약 자동화(회의/이슈 정리)", "```", "[역할] 너는 기술 PM이다.", "[목표] 아래 메모를 (1) 결정사항 (2) 미결정/리스크 (3) 액션아이템(담당/기한)으로 정리해줘.", "[제약] 액션아이템은 ‘완료 여부가 명확한 문장’으로 써줘.", "[입력] (회의 메모/슬랙 대화/이슈 내용)", "```", "", "### 4) 테스트 케이스 생성(엣지 케이스 중심)", "```", "[역할] 너는 QA 엔지니어다.", "[목표] 아래 기능 요구사항을 기반으로 테스트 케이스를 표로 만들어줘(정상/경계/오류/보안 포함).", "[맥락] 입력 스키마/제약/에러 코드…", "[형식] |케이스|입력|기대결과|비고|", "```", "", "### 5) ‘프롬프트’ 자체를 개선시키기(메타 프롬프트)", "```", "[목표] 내가 아래에 적은 프롬프트를 더 재현 가능하게 개선해줘.", "[제약] (1) 목표/제약/출력형식/평가기준을 분리해줘 (2) 필요한 질문 3개만 먼저 물어봐줘.", "[입력] (내 프롬프트)", "```", "", "## 실무에서 꼭 지킬 원칙 3가지", "- 비밀정보는 넣지 않기: API 키, 비밀번호, 개인 정보 등은 마스킹/제거", "- 출력 형식을 고정하기: 자동화할수록 형식(JSON/표/템플릿)이 중요", "- 검증 루프 만들기: 모델 답을 그대로 믿지 말고, 체크리스트/테스트로 검증", "", "---", "### 요약", "프롬프트 엔지니어링의 핵심은 명확한 목표와 제약, 그리고 평가 기준입니다.", "잘 설계하면 ‘운이 좋은 답’이 아니라 ‘재현 가능한 답’을 얻을 수 있습니다."] }

export const postList = [
  { ...meta_solid_overview, component: Post_solid_overview },
  { ...meta_mount_overview, component: Post_mount_overview },
  { ...meta_ssh_overview, component: Post_ssh_overview },
  { ...meta_git_overview, component: Post_git_overview },
  { ...meta_docker_core_concepts, component: Post_docker_core_concepts },
  { ...meta_solid_srp, component: Post_solid_srp },
  { ...meta_solid_ocp, component: Post_solid_ocp },
  { ...meta_solid_lsp, component: Post_solid_lsp },
  { ...meta_solid_isp, component: Post_solid_isp },
  { ...meta_solid_dip, component: Post_solid_dip },
  { ...meta_container_image_relationship, component: Post_container_image_relationship },
  { ...meta_docker_hub, component: Post_docker_hub },
  { ...meta_docker_pros_cons_use_cases, component: Post_docker_pros_cons_use_cases },
  { ...meta_docker_desktop, component: Post_docker_desktop },
  { ...meta_docker_vs_virtualization, component: Post_docker_vs_virtualization },
  { ...meta_container_os_reality, component: Post_container_os_reality },
  { ...meta_engine_in_software, component: Post_engine_in_software },
  { ...meta_server_overview, component: Post_server_overview },
  { ...meta_python_print, component: Post_python_print },
  { ...meta_abstract_factory_pattern, component: Post_abstract_factory_pattern },
  { ...meta_builder_pattern, component: Post_builder_pattern },
  { ...meta_singleton_pattern, component: Post_singleton_pattern },
  { ...meta_adapter_pattern, component: Post_adapter_pattern },
  { ...meta_decorator_pattern, component: Post_decorator_pattern },
  { ...meta_facade_pattern, component: Post_facade_pattern },
  { ...meta_proxy_pattern, component: Post_proxy_pattern },
  { ...meta_strategy_pattern, component: Post_strategy_pattern },
  { ...meta_observer_pattern, component: Post_observer_pattern },
  { ...meta_command_pattern, component: Post_command_pattern },
  { ...meta_state_pattern, component: Post_state_pattern },
  { ...meta_hello_pages, component: Post_hello_pages },
  { ...meta_ai_era_developer_growth, component: Post_ai_era_developer_growth },
  { ...meta_programming_language_types, component: Post_programming_language_types },
  { ...meta_orm_object_relational_mapping, component: Post_orm_object_relational_mapping },
  { ...meta_springboot_jpa_hibernate, component: Post_springboot_jpa_hibernate },
  { ...meta_springboot_rest_api, component: Post_springboot_rest_api },
  { ...meta_springboot_security_jwt, component: Post_springboot_security_jwt },
  { ...meta_springboot_webflux, component: Post_springboot_webflux },
  { ...meta_springboot_actuator, component: Post_springboot_actuator },
  { ...meta_springboot_docker, component: Post_springboot_docker },
  { ...meta_springboot_configuration, component: Post_springboot_configuration },
  { ...meta_springboot_test, component: Post_springboot_test },
  { ...meta_springboot_annotations, component: Post_springboot_annotations },
  { ...meta_springboot_request_response, component: Post_springboot_request_response },
  { ...meta_thymeleaf_overview, component: Post_thymeleaf_overview },
  { ...meta_accounting_overview, component: Post_accounting_overview },
  { ...meta_financial_statements, component: Post_financial_statements },
  { ...meta_income_statement_vs_balance_sheet, component: Post_income_statement_vs_balance_sheet },
  { ...meta_debit_credit, component: Post_debit_credit },
  { ...meta_assets_liabilities_equity, component: Post_assets_liabilities_equity },
  { ...meta_financial_accounting, component: Post_financial_accounting },
  { ...meta_management_accounting, component: Post_management_accounting },
  { ...meta_balance_sheet_guide, component: Post_balance_sheet_guide },
  { ...meta_income_statement_guide, component: Post_income_statement_guide },
  { ...meta_cash_flow_statement_guide, component: Post_cash_flow_statement_guide },
  { ...meta_statement_of_changes_in_equity_guide, component: Post_statement_of_changes_in_equity_guide },
  { ...meta_notes_to_financial_statements_guide, component: Post_notes_to_financial_statements_guide },
  { ...meta_stock_overview, component: Post_stock_overview },
  { ...meta_stock_market_and_brokerage, component: Post_stock_market_and_brokerage },
  { ...meta_stock_price_basics, component: Post_stock_price_basics },
  { ...meta_stock_investment_terms, component: Post_stock_investment_terms },
  { ...meta_stock_investment_basics, component: Post_stock_investment_basics },
  { ...meta_economics_overview, component: Post_economics_overview },
  { ...meta_gdp_and_economic_growth, component: Post_gdp_and_economic_growth },
  { ...meta_inflation_and_prices, component: Post_inflation_and_prices },
  { ...meta_interest_rates_and_monetary_policy, component: Post_interest_rates_and_monetary_policy },
  { ...meta_exchange_rate_basics, component: Post_exchange_rate_basics },
  { ...meta_economic_indicators_basics, component: Post_economic_indicators_basics },
  { ...meta_seed_money_basics, component: Post_seed_money_basics },
  { ...meta_tax_overview, component: Post_tax_overview },
  { ...meta_income_tax_basics, component: Post_income_tax_basics },
  { ...meta_four_big_insurance_and_tax, component: Post_four_big_insurance_and_tax },
  { ...meta_tax_deductions_basics, component: Post_tax_deductions_basics },
  { ...meta_year_end_tax_settlement_basics, component: Post_year_end_tax_settlement_basics },
  { ...meta_vat_basics, component: Post_vat_basics },
  { ...meta_real_estate_overview, component: Post_real_estate_overview },
  { ...meta_real_estate_transaction_basics, component: Post_real_estate_transaction_basics },
  { ...meta_apartment_terms, component: Post_apartment_terms },
  { ...meta_real_estate_loan_basics, component: Post_real_estate_loan_basics },
  { ...meta_jeonse_and_monthly_rent, component: Post_jeonse_and_monthly_rent },
  { ...meta_real_estate_tax_basics, component: Post_real_estate_tax_basics },
  { ...meta_registry_reading_guide, component: Post_registry_reading_guide },
  { ...meta_finance_overview, component: Post_finance_overview },
  { ...meta_banks_and_financial_institutions, component: Post_banks_and_financial_institutions },
  { ...meta_deposits_and_savings, component: Post_deposits_and_savings },
  { ...meta_interest_basics, component: Post_interest_basics },
  { ...meta_credit_and_credit_rating, component: Post_credit_and_credit_rating },
  { ...meta_loan_basics, component: Post_loan_basics },
  { ...meta_securities_basics, component: Post_securities_basics },
  { ...meta_financial_regulators_overview, component: Post_financial_regulators_overview },
  { ...meta_law_overview, component: Post_law_overview },
  { ...meta_civil_law_basics, component: Post_civil_law_basics },
  { ...meta_criminal_law_basics, component: Post_criminal_law_basics },
  { ...meta_labor_law_basics, component: Post_labor_law_basics },
  { ...meta_contract_basics, component: Post_contract_basics },
  { ...meta_legal_system_overview, component: Post_legal_system_overview },
  { ...meta_korea_three_branches, component: Post_korea_three_branches },
  { ...meta_korea_adult_resident_id, component: Post_korea_adult_resident_id },
  { ...meta_korea_adult_voting, component: Post_korea_adult_voting },
  { ...meta_korea_adult_government_services, component: Post_korea_adult_government_services },
  { ...meta_korea_adult_four_basic_duties, component: Post_korea_adult_four_basic_duties },
  { ...meta_korea_adult_citizen_rights_duties, component: Post_korea_adult_citizen_rights_duties },
  { ...meta_korea_adult_seal_notarization, component: Post_korea_adult_seal_notarization },
  { ...meta_design_patterns_overview, component: Post_design_patterns_overview },
  { ...meta_factory_method_pattern, component: Post_factory_method_pattern },
  { ...meta_ai_ml_dl_overview, component: Post_ai_ml_dl_overview },
  { ...meta_prompt_engineering, component: Post_prompt_engineering }
].sort((a, b) => String(b.date || '').localeCompare(String(a.date || '')))

export const postMetaById = Object.fromEntries(postList.map((p) => [p.id, p]))

export function getPostComponent(id) {
  const p = postList.find((x) => x.id === id)
  return p?.component
}
