<script setup>
import ArticleHeader from '@/components/ArticleHeader.vue'
import ArticleBody from '@/components/ArticleBody.vue'

const post = {
  id: "springboot-webflux",
  title: "Spring WebFlux와 리액티브 프로그래밍",
  date: "2026-02-11",
  summary: "Spring WebFlux, Project Reactor, Mono/Flux 기초부터 리액티브 REST API 구현까지. 블로킹 vs 논블로킹, 언제 WebFlux를 쓰는지 정리합니다.",
  category: "Technology/SpringBoot",
  tags: ["springboot","webflux","reactive","reactor","backend"],
  content: ["## Spring WebFlux란?", "Spring WebFlux는 논블로킹(non-blocking) 기반의 리액티브 웹 프레임워크입니다. Project Reactor의 Mono/Flux를 사용해 적은 스레드로 많은 동시 요청을 처리할 수 있습니다.", "", "## MVC vs WebFlux", "| 구분 | Spring MVC | Spring WebFlux |", "|------|------------|----------------|", "| 모델 | 블로킹, 스레드당 1요청 | 논블로킹, 이벤트 루프 |", "| 스레드 | 요청당 1스레드 | 공유 스레드 풀 |", "| 적합 | DB·외부 API 블로킹 많을 때 | I/O 대기 많고 동시성 높을 때 |", "", "## 1) 의존성", "```xml", "<dependency>", "    <groupId>org.springframework.boot</groupId>", "    <artifactId>spring-boot-starter-webflux</artifactId>", "</dependency>", "```", "", "※ `spring-boot-starter-web`과 `spring-boot-starter-webflux`를 동시에 쓰면 WebFlux가 MVC를 오버라이드합니다. 함께 쓰려면 WebFlux를 명시적으로 라우터 방식으로만 사용해야 합니다.", "", "## 2) 리액티브 Controller 예제", "```java", "@RestController", "@RequestMapping(\"/api/products\")", "public class ProductController {", "    private final ProductRepository productRepo;", "", "    @GetMapping", "    public Flux<Product> list() {", "        return productRepo.findAll();", "    }", "", "    @GetMapping(\"/{id}\")", "    public Mono<Product> get(@PathVariable String id) {", "        return productRepo.findById(id)", "            .switchIfEmpty(Mono.error(new ResponseStatusException(", "                HttpStatus.NOT_FOUND, \"Product not found\")));", "    }", "", "    @PostMapping", "    @ResponseStatus(HttpStatus.CREATED)", "    public Mono<Product> create(@RequestBody Mono<ProductRequest> req) {", "        return req.flatMap(r -> productRepo.save(toEntity(r)));", "    }", "}", "```", "", "## 3) Mono vs Flux", "- **Mono<T>**: 0 또는 1개의 결과 (비유: Optional)", "- **Flux<T>**: 0~N개의 스트림 (비유: Stream)", "", "```java", "// 단일 값", "Mono<User> user = userRepo.findById(1L);", "", "// 스트림", "Flux<Order> orders = orderRepo.findByUserId(userId);", "", "// 조합", "Mono<User> withOrders = userRepo.findById(1L)", "    .flatMap(u -> orderRepo.findByUserId(u.getId()).collectList())", "    .map(orders -> new UserWithOrders(u, orders));", "```", "", "## 4) 함수형 라우팅 (Router + Handler)", "```java", "@Configuration", "public class RouterConfig {", "    @Bean", "    public RouterFunction<ServerResponse> route(ProductHandler handler) {", "        return RouterFunctions", "            .route(GET(\"/api/v2/products\"), handler::list)", "            .andRoute(GET(\"/api/v2/products/{id}\"), handler::get);", "    }", "}", "", "@Component", "public class ProductHandler {", "    private final ProductRepository repo;", "    public Mono<ServerResponse> list(ServerRequest req) {", "        return ServerResponse.ok()", "            .body(repo.findAll(), Product.class);", "    }", "}", "```", "", "## 5) WebClient (리액티브 HTTP 클라이언트)", "```java", "@Service", "public class ExternalApiService {", "    private final WebClient webClient;", "", "    public ExternalApiService(WebClient.Builder builder) {", "        this.webClient = builder.baseUrl(\"https://api.example.com\").build();", "    }", "", "    public Mono<ApiResponse> fetch(String id) {", "        return webClient.get().uri(\"/items/{id}\", id)", "            .retrieve()", "            .bodyToMono(ApiResponse.class);", "    }", "}", "```", "", "## 언제 WebFlux를 쓸까", "- 고동시성, 저지연이 중요한 서비스(실시간, SSE, WebSocket)", "- 외부 API 호출이 많고 논블로킹 I/O로 이득을 볼 때", "- 기존 스택이 리액티브(예: R2DBC, MongoDB 리액티브 드라이버)일 때", "", "※ DB가 JDBC(블로킹)이면 WebFlux 이점이 줄어듭니다. R2DBC 등 리액티브 DB 드라이버와 함께 써야 진가를 발휘합니다.", "", "## 정리", "Spring WebFlux는 논블로킹·리액티브 스택의 핵심입니다. 실무에서는 트래픽 패턴과 기존 DB/외부 연동 방식에 따라 MVC vs WebFlux를 선택하면 됩니다."]
}
</script>

<template>
  <ArticleHeader :post="post" />
  <ArticleBody :content="post.content" />
</template>
