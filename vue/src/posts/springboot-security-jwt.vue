<script setup>
import ArticleHeader from '@/components/ArticleHeader.vue'
import ArticleBody from '@/components/ArticleBody.vue'

const post = {
  id: "springboot-security-jwt",
  title: "Spring Security + JWT 인증 구현",
  date: "2026-02-11",
  summary: "Spring Security 6.x와 JWT(JSON Web Token)를 사용한 Stateless 인증 방식을 구현하는 방법과 예제 코드를 정리합니다.",
  category: "Technology/SpringBoot",
  tags: ["springboot","security","jwt","authentication","backend"],
  content: ["## Spring Security + JWT란?", "JWT는 서버가 상태를 저장하지 않고, 토큰 자체에 사용자 정보와 서명을 담아 클라이언트가 요청 시 보내는 Stateless 인증 방식입니다. Spring Security 6에서는 SecurityFilterChain 기반으로 구성합니다.", "", "## 1) 의존성", "```xml", "<dependency>", "    <groupId>org.springframework.boot</groupId>", "    <artifactId>spring-boot-starter-security</artifactId>", "</dependency>", "<dependency>", "    <groupId>io.jsonwebtoken</groupId>", "    <artifactId>jjwt-api</artifactId>", "    <version>0.12.5</version>", "</dependency>", "<dependency>", "    <groupId>io.jsonwebtoken</groupId>", "    <artifactId>jjwt-impl</artifactId>", "    <version>0.12.5</version>", "    <scope>runtime</scope>", "</dependency>", "```", "", "## 2) JWT 유틸리티", "```java", "@Component", "public class JwtUtil {", "    @Value(\"${jwt.secret}\")", "    private String secret;", "    @Value(\"${jwt.expiration-ms:86400000}\")", "    private long expirationMs;", "", "    public String generateToken(String username) {", "        return Jwts.builder()", "            .subject(username)", "            .issuedAt(new Date())", "            .expiration(new Date(System.currentTimeMillis() + expirationMs))", "            .signWith(getSigningKey())", "            .compact();", "    }", "", "    public String extractUsername(String token) {", "        return Jwts.parser()", "            .verifyWith(getSigningKey())", "            .build()", "            .parseSignedClaims(token)", "            .getPayload()", "            .getSubject();", "    }", "", "    private SecretKey getSigningKey() {", "        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(secret));", "    }", "}", "```", "", "## 3) JWT 필터", "```java", "public class JwtAuthenticationFilter extends OncePerRequestFilter {", "    private final JwtUtil jwtUtil;", "", "    @Override", "    protected void doFilterInternal(HttpServletRequest request,", "            HttpServletResponse response, FilterChain chain)", "            throws ServletException, IOException {", "        String token = extractToken(request);", "        if (token != null) {", "            String username = jwtUtil.extractUsername(token);", "            var auth = new UsernamePasswordAuthenticationToken(", "                username, null, List.of(new SimpleGrantedAuthority(\"ROLE_USER\")));", "            SecurityContextHolder.getContext().setAuthentication(auth);", "        }", "        chain.doFilter(request, response);", "    }", "", "    private String extractToken(HttpServletRequest req) {", "        String bearer = req.getHeader(\"Authorization\");", "        if (bearer != null && bearer.startsWith(\"Bearer \"))", "            return bearer.substring(7);", "        return null;", "    }", "}", "```", "", "## 4) Security 설정", "```java", "@Configuration", "@EnableWebSecurity", "public class SecurityConfig {", "    private final JwtAuthenticationFilter jwtFilter;", "", "    @Bean", "    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {", "        return http", "            .csrf(csrf -> csrf.disable())", "            .sessionManagement(s -> s.sessionCreationPolicy(", "                SessionCreationPolicy.STATELESS))", "            .authorizeHttpRequests(a -> a", "                .requestMatchers(\"/api/auth/**\").permitAll()", "                .requestMatchers(\"/api/**\").authenticated())", "            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)", "            .build();", "    }", "}", "```", "", "## 5) 로그인 엔드포인트", "```java", "@RestController", "@RequestMapping(\"/api/auth\")", "public class AuthController {", "    private final UserDetailsService userService;", "    private final PasswordEncoder passwordEncoder;", "    private final JwtUtil jwtUtil;", "", "    @PostMapping(\"/login\")", "    public Map<String, String> login(@RequestBody LoginRequest req) {", "        var user = userService.loadUserByUsername(req.username());", "        if (!passwordEncoder.matches(req.password(), user.getPassword()))", "            throw new BadCredentialsException(\"Invalid credentials\");", "        String token = jwtUtil.generateToken(req.username());", "        return Map.of(\"accessToken\", token, \"tokenType\", \"Bearer\");", "    }", "}", "```", "", "## application.yml", "```yaml", "jwt:", "  secret: ${JWT_SECRET:your-base64-encoded-256bit-secret-here}", "  expiration-ms: 86400000  # 24시간", "```", "", "## 정리", "Spring Security 6 + JWT는 Stateless 인증의 대표 조합입니다. 토큰 갱신(Refresh Token), 블랙리스트, Rate Limiting 등은 실서비스에서 추가로 고려해야 합니다."]
}
</script>

<template>
  <ArticleHeader :post="post" />
  <ArticleBody :content="post.content" />
</template>
